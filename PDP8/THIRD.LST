   1            	*20
   2            /------------------------------------------------------------------------
   3            /
   4            / File:	header.pal8
   5            /
   6            / Description:
   7            /
   8            /	This file contains the variables and routines needed to
   9            /	implement the Stupid VM used by the PDP/8 version of THIRD.
  10            /	This VM is implemented as subroutine calls to the routines that
  11            /	implement each THIRD Stupid operation. The Stupid operations
  12            /	use a limited-depth stack-based model as a basis from which
  13            /	to build the THIRD environment. The actual routines implemented
  14            /	here are precisely those needed to implement the THIRD
  15            /	environment; i.e., no operations are implemented that are
  16            /	not actually used by THIRD.
  17            /
  18            / Revisions:
  19            /
  20            /	09/10/99 RLI - Initial version for 68HC908GP20 on the AVNET
  21            /		       evaluation module.
  22            /	09/14/99 RLI - Moved most of the stuff to trailer.as6808
  23            /	04/19/01 RLI - Liberated and made into Z80 version. This is
  24            /	               currently targetted to run under CP/M.
  25            /	05/03/01 RLI - Liberated and made into PDP-8 version. This is
  26            /	               targeted to run standalone with a standard console.
  27            
  28            
  29            /	Here's the math stack
  30            
  31 00020 0000 StupidR0,	0
  32 00021 0000 StupidR1,	0
  33 00022 0000 StupidR2,	0
  34 00023 0000 StupidR3,	0
  35            
  36            /	An extra register to handle SWAP
  37            
  38 00024 0000 StupidSwapReg,	0
  39            
  40            /	Many of the Stupid global registers are pseudo-registers
  41            /	implemented by stuffing in constants as the Stupid VM fetch
  42            /	for that register. Here are the globals which actually
  43            /	require storage behind them.
  44            
  45 00025 0000 StupidCFA,	0
  46 00026 0000 StupidIP,	0
  47 00027 0000 StupidMP,	0
  48 00030 0000 StupidRP,	0
  49            
  50            /	Handy vector to Next.
  51            
  52 00031 1211 Next,	SL1
  53            
  54            /	Vectors to the code which actually implement the Stupid VM
  55            /	operations. Placing these vectors here allows all of the
  56            /	Stupid VM operations to be invoked with a single word;
  57            /	a JMS I through the vector location in page 0.
  58            
  59            StupidAnd1,
  60 00032 0211 	DoStupidAnd1
  61            StupidDup1,
  62 00033 0217 	DoStupidDup1
  63            StupidElseGo0,
  64 00034 0224 	DoStupidElseGo0
  65            StupidFetch0,
  66 00035 0237 	DoStupidFetch0
  67            StupidFetch1,
  68 00036 0244 	DoStupidFetch1
  69            StupidFetchCFA0,
  70 00037 0251 	DoStupidFetchCFA0
  71            StupidFetchCFA1,
  72 00040 0256 	DoStupidFetchCFA1
  73            StupidFetchIP0,
  74 00041 0263 	DoStupidFetchIP0
  75            StupidFetchIP1,
  76 00042 0270 	DoStupidFetchIP1
  77            StupidFetchInitialDP0,
  78 00043 0275 	DoStupidFetchInitialDP0
  79            StupidFetchInitialLAST0,
  80 00044 0302 	DoStupidFetchInitialLAST0
  81            StupidFetchInitialMP0,
  82 00045 0307 	DoStupidFetchInitialMP0
  83            StupidFetchInitialRP0,
  84 00046 0314 	DoStupidFetchInitialRP0
  85            StupidFetchMP0,
  86 00047 0321 	DoStupidFetchMP0
  87            StupidFetchMP1,
  88 00050 0326 	DoStupidFetchMP1
  89            StupidFetchMP2,
  90 00051 0333 	DoStupidFetchMP2
  91            StupidFetchMP3,
  92 00052 0340 	DoStupidFetchMP3
  93            StupidFetchNEXT0,
  94 00053 0345 	DoStupidFetchNEXT0
  95            StupidFetchRP0,
  96 00054 0352 	DoStupidFetchRP0
  97            StupidFetchRP1,
  98 00055 0357 	DoStupidFetchRP1
  99            StupidFetchRP2,
 100 00056 0364 	DoStupidFetchRP2
 101            StupidLessGo1,
 102 00057 0400 	DoStupidLessGo1
 103            StupidLiteral0,
 104 00060 0415 	DoStupidLiteral0
 105            StupidLiteral1,
 106 00061 0423 	DoStupidLiteral1
 107            StupidLiteral2,
 108 00062 0431 	DoStupidLiteral2
 109            StupidMinus1,
 110 00063 0437 	DoStupidMinus1
 111            StupidMinus2,
 112 00064 0446 	DoStupidMinus2
 113            StupidMinus3,
 114 00065 0455 	DoStupidMinus3
 115            StupidNeg0,
 116 00066 0464 	DoStupidNeg0
 117            StupidNot0,
 118 00067 0472 	DoStupidNot0
 119            StupidOr1,
 120 00070 0500 	DoStupidOr1
 121            StupidPlus1,
 122 00071 0510 	DoStupidPlus1
 123            StupidPlus2,
 124 00072 0516 	DoStupidPlus2
 125            StupidShiftLeft1,
 126 00073 0532 	DoStupidShiftLeft1
 127            StupidShiftRight1,
 128 00074 0547 	DoStupidShiftRight1
 129            StupidStore1,
 130 00075 0564 	DoStupidStore1
 131            StupidStore2,
 132 00076 0571 	DoStupidStore2
 133            StupidStoreCFA0,
 134 00077 0600 	DoStupidStoreCFA0
 135            StupidStoreIP0,
 136 00100 0605 	DoStupidStoreIP0
 137            StupidStoreMP0,
 138 00101 0612 	DoStupidStoreMP0
 139            StupidStoreMP1,
 140 00102 0617 	DoStupidStoreMP1
 141            StupidStorePC0,
 142 00103 0624 	DoStupidStorePC0
 143            StupidStoreRP0,
 144 00104 0626 	DoStupidStoreRP0
 145            StupidSwap1,
 146 00105 0633 	DoStupidSwap1
 147            StupidSwap2,
 148 00106 0644 	DoStupidSwap2
 149            StupidSwap3,
 150 00107 0655 	DoStupidSwap3
 151            

 . . . 

 152            	EJECT
 153            	*200
 154            
 155            /	Execution begins here
 156            
 157            Reset,
 158            
 159            /	Initialize the THIRD virtual machine: we need to set up the
 160            /	stack pointers and IP.
 161            
 162 00200 7200 	CLA
 163            
 164 00201 1377 	TAD (ReturnStackBottom)
 165 00202 3030 	DCA StupidRP
 166            
 167 00203 1376 	TAD (MathStackBottom)
 168 00204 3027 	DCA StupidMP
 169            
 170 00205 1375 	TAD (W1000PFA)
 171 00206 3026 	DCA StupidIP
 172            
 173 00207 6040 	6040			/ TFL: Set console output ready flag
 174            
 175 00210 5431 	JMP I Next		/ Enter at Next
 176            
 177            /	InitialDP is the address of the first unused RAM location. The
 178            /	space allocated for new user-created words begins here.
 179            
 180            InitialDP= RamEnd
 181            
 182            /	InitialLAST is the address of the CFA of the last definition in
 183            /	the dictionary. We start by pointing it at (LASTWORD), which is given
 184            /	the fixed number 1001.
 185            
 186            InitialLAST= W1001CFA
 187            
 188            
 189            /---	StupidAnd1		R0 <- R0 AND R1
 190            
 191 00211 0000 DoStupidAnd1, .-.
 192 00212 7200 	CLA
 193 00213 1020 	TAD StupidR0
 194 00214 0021 	AND StupidR1
 195 00215 3020 	DCA StupidR0
 196 00216 5611 	JMP I DoStupidAnd1
 197            
 198            /---	StupidDup1		R1 <- R0
 199            
 200 00217 0000 DoStupidDup1, .-.
 201 00220 7200 	CLA
 202 00221 1020 	TAD StupidR0
 203 00222 3021 	DCA StupidR1
 204 00223 5617 	JMP I DoStupidDup1
 205            
 206            /---	StupidElseGo0		Branch if R0 = 0
 207            /
 208            /	The call is followed by a word containing the branch address.
 209            /	If R0 is not 0, this word must be skipped. Otherwise, the word
 210            /	is used as a branch address.
 211            
 212 00224 0000 DoStupidElseGo0, .-.
 213 00225 7200 	CLA
 214 00226 1020 	TAD StupidR0
 215 00227 7440 	SZA
 216 00230 5235 	JMP DoStupidElseGo0DontBranch
 217            
 218            /	We need to branch. Fetch the branch address (it's pointed to
 219            /	by the return address) and jump to it (there may be a more
 220            /	clever way to do this than to replace the return address with
 221            /	the branch address, but I'm not very bright).
 222            
 223 00231 7200 	CLA			/ Get branch address
 224 00232 1624 	TAD I DoStupidElseGo0
 225 00233 3224 	DCA DoStupidElseGo0	/ Jump to it
 226 00234 5624 	JMP I DoStupidElseGo0
 227            
 228            /	We don't need to branch. This is equivalent to branching to the
 229            /	word following the word we pulled. Increment the return address
 230            /	and jump to it.
 231            
 232            DoStupidElseGo0DontBranch,
 233 00235 2224 	ISZ DoStupidElseGo0	/ How likely we'll be called from 7777???
 234 00236 5624 	JMP I DoStupidElseGo0
 235            
 236            /---	StupidFetch0		R0 <- (R0)
 237            
 238 00237 0000 DoStupidFetch0, .-.
 239 00240 7200 	CLA
 240 00241 1420 	TAD I StupidR0
 241 00242 3020 	DCA StupidR0
 242 00243 5637 	JMP I DoStupidFetch0
 243            
 244            /---	StupidFetch1		R1 <- (R1)
 245            
 246 00244 0000 DoStupidFetch1, .-.
 247 00245 7200 	CLA
 248 00246 1421 	TAD I StupidR1
 249 00247 3021 	DCA StupidR1
 250 00250 5644 	JMP I DoStupidFetch1
 251            
 252            /---	StupidFetchCFA0		R0 <- CFA
 253            
 254 00251 0000 DoStupidFetchCFA0, .-.
 255 00252 7200 	CLA
 256 00253 1025 	TAD StupidCFA
 257 00254 3020 	DCA StupidR0
 258 00255 5651 	JMP I DoStupidFetchCFA0
 259            
 260            /---	StupidFetchCFA1		R1 <- CFA
 261            
 262 00256 0000 DoStupidFetchCFA1, .-.
 263 00257 7200 	CLA
 264 00260 1025 	TAD StupidCFA
 265 00261 3021 	DCA StupidR1
 266 00262 5656 	JMP I DoStupidFetchCFA1
 267            
 268            /---	StupidFetchIP0		R0 <- IP
 269            
 270 00263 0000 DoStupidFetchIP0, .-.
 271 00264 7200 	CLA
 272 00265 1026 	TAD StupidIP
 273 00266 3020 	DCA StupidR0
 274 00267 5663 	JMP I DoStupidFetchIP0
 275            
 276            /---	StupidFetchIP1		R1 <- IP
 277            
 278 00270 0000 DoStupidFetchIP1, .-.
 279 00271 7200 	CLA
 280 00272 1026 	TAD StupidIP
 281 00273 3021 	DCA StupidR1
 282 00274 5670 	JMP I DoStupidFetchIP1
 283            
 284            /---	StupidFetchInitialDP0	R0 <- InitialDP
 285            
 286 00275 0000 DoStupidFetchInitialDP0, .-.
 287 00276 7200 	CLA
 288 00277 1374 	TAD (InitialDP)
 289 00300 3020 	DCA StupidR0
 290 00301 5675 	JMP I DoStupidFetchInitialDP0
 291            
 292            /---	StupidFetchInitialLAST0	R0 <- InitialLAST
 293            
 294 00302 0000 DoStupidFetchInitialLAST0, .-.
 295 00303 7200 	CLA
 296 00304 1373 	TAD (InitialLAST)
 297 00305 3020 	DCA StupidR0
 298 00306 5702 	JMP I DoStupidFetchInitialLAST0
 299            
 300            /---	StupidFetchInitialMP0	R0 <- InitialMP
 301            
 302 00307 0000 DoStupidFetchInitialMP0, .-.
 303 00310 7200 	CLA
 304 00311 1376 	TAD (MathStackBottom)
 305 00312 3020 	DCA StupidR0
 306 00313 5707 	JMP I DoStupidFetchInitialMP0
 307            
 308            /---	StupidFetchInitialRP0	R0 <- InitialRP
 309            
 310 00314 0000 DoStupidFetchInitialRP0, .-.
 311 00315 7200 	CLA
 312 00316 1377 	TAD (ReturnStackBottom)
 313 00317 3020 	DCA StupidR0
 314 00320 5714 	JMP I DoStupidFetchInitialRP0
 315            
 316            /---	StupidFetchMP0		R0 <- MP
 317            
 318 00321 0000 DoStupidFetchMP0, .-.
 319 00322 7200 	CLA
 320 00323 1027 	TAD StupidMP
 321 00324 3020 	DCA StupidR0
 322 00325 5721 	JMP I DoStupidFetchMP0
 323            
 324            /---	StupidFetchMP1		R1 <- MP
 325            
 326 00326 0000 DoStupidFetchMP1, .-.
 327 00327 7200 	CLA
 328 00330 1027 	TAD StupidMP
 329 00331 3021 	DCA StupidR1
 330 00332 5726 	JMP I DoStupidFetchMP1
 331            
 332            /---	StupidFetchMP2		R2 <- MP
 333            
 334 00333 0000 DoStupidFetchMP2, .-.
 335 00334 7200 	CLA
 336 00335 1027 	TAD StupidMP
 337 00336 3022 	DCA StupidR2
 338 00337 5733 	JMP I DoStupidFetchMP2
 339            
 340            /---	StupidFetchMP3		R3 <- MP
 341            
 342 00340 0000 DoStupidFetchMP3, .-.
 343 00341 7200 	CLA
 344 00342 1027 	TAD StupidMP
 345 00343 3023 	DCA StupidR3
 346 00344 5740 	JMP I DoStupidFetchMP3
 347            
 348            /---	StupidFetchNEXT0	R0 <- Next:
 349            
 350 00345 0000 DoStupidFetchNEXT0, .-.
 351 00346 7200 	CLA
 352 00347 1031 	TAD Next		/ Next
 353 00350 3020 	DCA StupidR0
 354 00351 5745 	JMP I DoStupidFetchNEXT0
 355            
 356            /---	StupidFetchRP0		R0 <- RP
 357            
 358 00352 0000 DoStupidFetchRP0, .-.
 359 00353 7200 	CLA
 360 00354 1030 	TAD StupidRP
 361 00355 3020 	DCA StupidR0
 362 00356 5752 	JMP I DoStupidFetchRP0
 363            
 364            /---	StupidFetchRP1		R1 <- RP
 365            
 366 00357 0000 DoStupidFetchRP1, .-.
 367 00360 7200 	CLA
 368 00361 1030 	TAD StupidRP
 369 00362 3021 	DCA StupidR1
 370 00363 5757 	JMP I DoStupidFetchRP1
 371            
 372            /---	StupidFetchRP2		R2 <- RP
 373            
 374 00364 0000 DoStupidFetchRP2, .-.
 375 00365 7200 	CLA
 376 00366 1030 	TAD StupidRP
 377 00367 3022 	DCA StupidR2
 378 00370 5764 	JMP I DoStupidFetchRP2
 379            
 380 00373 6275 	PAGE
     00374 6277 
     00375 4663 
     00376 0722 
     00377 1122 
 381            /---	StupidLessGo1		Branch if r0<r1
 382            /
 383            /	The call to StupidLessGo is followed by a word containing the
 384            /	address to which the branch is to be made. If the branch is
 385            /	not made, that word must be skipped.
 386            
 387 00400 0000 DoStupidLessGo1, .-.
 388            
 389            /	Determine whether R0 is less than R1 by subtracting R1 from R0.
 390            /	If there's a carry out, R0 is less than R1.
 391            
 392 00401 7300 	CLA CLL
 393 00402 1021 	TAD StupidR1		/ Form -R1
 394 00403 7041 	CMA IAC			/ Can link become set here???
 395 00404 1020 	TAD StupidR0		/ Form R0-R1. Link becomes set on carry.
 396 00405 7420 	SNL			/ If no link, don't branch.
 397 00406 5211 	JMP DoStupidLessGo1Branch
 398            
 399            /	We don't need to branch. Skip the branch address and return.
 400            
 401 00407 2200 	ISZ DoStupidLessGo1	/ How likely we'll be called from 7777???
 402 00410 5600 	JMP I DoStupidLessGo1
 403            
 404            DoStupidLessGo1Branch,
 405            
 406            /	We need to branch. Replace the return address with the branch
 407            /	address.
 408            
 409 00411 7200 	CLA
 410 00412 1600 	TAD I DoStupidLessGo1
 411 00413 3200 	DCA DoStupidLessGo1
 412 00414 5600 	JMP I DoStupidLessGo1
 413            
 414            /---	StupidLiteral0		R0 <- Literal
 415            /
 416            /	The call to StupidLiteralx is followed by a word containing the
 417            /	literal. The literal needs to be loaded into the register and
 418            /	the word containing the literal needs to be skipped.
 419            
 420 00415 0000 DoStupidLiteral0, .-.
 421 00416 7200 	CLA
 422 00417 1615 	TAD I DoStupidLiteral0
 423 00420 3020 	DCA StupidR0
 424 00421 2215 	ISZ DoStupidLiteral0	/ How likely we'll be called from 7777???
 425 00422 5615 	JMP I DoStupidLiteral0
 426            
 427            /---	StupidLiteral1		R1 <- Literal
 428            
 429 00423 0000 DoStupidLiteral1, .-.
 430 00424 7200 	CLA
 431 00425 1623 	TAD I DoStupidLiteral1
 432 00426 3021 	DCA StupidR1
 433 00427 2223 	ISZ DoStupidLiteral1	/ How likely we'll be called from 7777???
 434 00430 5623 	JMP I DoStupidLiteral1
 435            
 436            /---	StupidLiteral2		R2 <- Literal
 437            
 438 00431 0000 DoStupidLiteral2, .-.
 439 00432 7200 	CLA
 440 00433 1631 	TAD I DoStupidLiteral2
 441 00434 3022 	DCA StupidR2
 442 00435 2231 	ISZ DoStupidLiteral2	/ How likely we'll be called from 7777???
 443 00436 5631 	JMP I DoStupidLiteral2
 444            
 445            /---	StupidMinus1		R0 <- R0 - R1
 446            
 447 00437 0000 DoStupidMinus1, .-.
 448 00440 7200 	CLA
 449 00441 1021 	TAD StupidR1		/ Form -R1
 450 00442 7041 	CMA IAC
 451 00443 1020 	TAD StupidR0		/ Form R0-R1
 452 00444 3020 	DCA StupidR0
 453 00445 5637 	JMP I DoStupidMinus1
 454            
 455            /---	StupidMinus2		R1 <- R1 - R2
 456            
 457 00446 0000 DoStupidMinus2, .-.
 458 00447 7200 	CLA
 459 00450 1022 	TAD StupidR2		/ Form -R2
 460 00451 7041 	CMA IAC
 461 00452 1021 	TAD StupidR1		/ Form R1-R2
 462 00453 3021 	DCA StupidR1
 463 00454 5646 	JMP I DoStupidMinus2
 464            
 465            /---	StupidMinus3		R2 <- R2 - R3
 466            
 467 00455 0000 DoStupidMinus3, .-.
 468 00456 7200 	CLA
 469 00457 1023 	TAD StupidR3		/ Form -R3
 470 00460 7041 	CMA IAC
 471 00461 1022 	TAD StupidR2		/ Form R2-R3
 472 00462 3022 	DCA StupidR2
 473 00463 5655 	JMP I DoStupidMinus3
 474            
 475            /---	StupidNeg0		R0 <- 0 - R0
 476            
 477 00464 0000 DoStupidNeg0, .-.
 478 00465 7200 	CLA
 479 00466 1020 	TAD StupidR0
 480 00467 7041 	CMA IAC
 481 00470 3020 	DCA StupidR0
 482 00471 5664 	JMP I DoStupidNeg0
 483            
 484            /---	StupidNot0		R0 <- ~R0
 485            
 486 00472 0000 DoStupidNot0, .-.
 487 00473 7200 	CLA
 488 00474 1020 	TAD StupidR0
 489 00475 7040 	CMA
 490 00476 3020 	DCA StupidR0
 491 00477 5672 	JMP I DoStupidNot0
 492            
 493            /---	StupidOr1		R0 <- R0 or R1
 494            /
 495            /	OK, this is a little complicated. We need to clear the bits in
 496            /	R0 that are also set in R1 and then add R0 and R1 together.
 497            
 498 00500 0000 DoStupidOr1, .-.
 499 00501 7200 	CLA
 500 00502 1021 	TAD StupidR1		/ Form ~R1
 501 00503 7040 	CMA
 502 00504 0020 	AND StupidR0		/ Form R0&~R1. This clears bits in R0
 503            				/ which are also set in R1.
 504 00505 1021 	TAD StupidR1		/ Add the set bits back in.
 505 00506 3020 	DCA StupidR0
 506 00507 5700 	JMP I DoStupidOr1
 507            
 508            /---	StupidPlus1		R0 <- R0 + R1
 509            
 510 00510 0000 DoStupidPlus1, .-.
 511 00511 7200 	CLA
 512 00512 1020 	TAD StupidR0
 513 00513 1021 	TAD StupidR1
 514 00514 3020 	DCA StupidR0
 515 00515 5710 	JMP I DoStupidPlus1
 516            
 517            /---	StupidPlus2		R1 <- R1 + R2
 518            
 519 00516 0000 DoStupidPlus2, .-.
 520 00517 7200 	CLA
 521 00520 1022 	TAD StupidR2
 522 00521 1021 	TAD StupidR1
 523 00522 3021 	DCA StupidR1
 524 00523 5716 	JMP I DoStupidPlus2
 525            
 526            /---	StupidPlus3		R2 <- R2 + R3
 527            
 528 00524 0000 DoStupidPlus3, .-.
 529 00525 7200 	CLA
 530 00526 1023 	TAD StupidR3
 531 00527 1022 	TAD StupidR2
 532 00530 3022 	DCA StupidR2
 533 00531 5724 	JMP I DoStupidPlus3
 534            
 535            /---	StupidShiftLeft1	R0 <- R0 << R1
 536            /
 537            /	This is a little complicated, too. We need the two's complement
 538            /	of the bit shift count for ISZ, but we also need to not do anything
 539            /	if the count is 0.
 540            
 541 00532 0000 DoStupidShiftLeft1, .-.
 542            
 543            /	Fetch the bit count. If it's zero, exit without doing anything.
 544            
 545 00533 7200 	CLA
 546 00534 1021 	TAD StupidR1
 547 00535 7450 	SNA
 548 00536 5732 	JMP I DoStupidShiftLeft1
 549            
 550            /	Form the two's complement of the bit count.
 551            
 552 00537 7041 	CMA IAC
 553 00540 3021 	DCA StupidR1
 554            
 555            /	Fetch the victim and shift it left until the count rolls over.
 556            
 557 00541 1020 	TAD StupidR0
 558            DoStupidShiftLeft1Loop,
 559 00542 7104 	CLL RAL			/ Clear link to make it a shift
 560 00543 2021 	ISZ StupidR1
 561 00544 5342 	JMP DoStupidShiftLeft1Loop
 562            
 563            /	We're done. Store the result and exit.
 564            
 565 00545 3020 	DCA StupidR0
 566 00546 5732 	JMP I DoStupidShiftLeft1
 567            
 568            /---	StupidShiftRight1	R0 <- R0 >> R1
 569            /
 570            /	See StupidShiftLeft1.
 571            
 572 00547 0000 DoStupidShiftRight1, .-.
 573            
 574            /	Fetch the bit count. If it's zero, exit without doing anything.
 575            
 576 00550 7200 	CLA
 577 00551 1021 	TAD StupidR1
 578 00552 7450 	SNA
 579 00553 5747 	JMP I DoStupidShiftRight1
 580            
 581            /	Form the two's complement of the bit count.
 582            
 583 00554 7041 	CMA IAC
 584 00555 3021 	DCA StupidR1
 585            
 586            /	Fetch the victim and shift it right until the count rolls over.
 587            
 588 00556 1020 	TAD StupidR0
 589            DoStupidShiftRight1Loop,
 590 00557 7110 	CLL RAR			/ Clear link to make it a shift
 591 00560 2021 	ISZ StupidR1
 592 00561 5357 	JMP DoStupidShiftRight1Loop
 593            
 594            /	We're done. Store the result and exit.
 595            
 596 00562 3020 	DCA StupidR0
 597 00563 5747 	JMP I DoStupidShiftRight1
 598            
 599            /---	StupidStore1		(R1) <- R0
 600            
 601 00564 0000 DoStupidStore1, .-.
 602 00565 7200 	CLA
 603 00566 1020 	TAD StupidR0
 604 00567 3421 	DCA I StupidR1
 605 00570 5764 	JMP I DoStupidStore1
 606            
 607            /---	StupidStore2		(R2) <- R1
 608            
 609 00571 0000 DoStupidStore2, .-.
 610 00572 7200 	CLA
 611 00573 1021 	TAD StupidR1
 612 00574 3422 	DCA I StupidR2
 613 00575 5771 	JMP I DoStupidStore2
 614            
 615            	PAGE
 616            /---	StupidStoreCFA0		CFA <- R0
 617            
 618 00600 0000 DoStupidStoreCFA0, .-.
 619 00601 7200 	CLA
 620 00602 1020 	TAD StupidR0
 621 00603 3025 	DCA StupidCFA
 622 00604 5600 	JMP I DoStupidStoreCFA0
 623            
 624            /---	StupidStoreIP0		IP <- R0
 625            
 626 00605 0000 DoStupidStoreIP0, .-.
 627 00606 7200 	CLA
 628 00607 1020 	TAD StupidR0
 629 00610 3026 	DCA StupidIP
 630 00611 5605 	JMP I DoStupidStoreIP0
 631            
 632            /---	StupidStoreMP0		MP <- R0
 633            
 634 00612 0000 DoStupidStoreMP0, .-.
 635 00613 7200 	CLA
 636 00614 1020 	TAD StupidR0
 637 00615 3027 	DCA StupidMP
 638 00616 5612 	JMP I DoStupidStoreMP0
 639            
 640            /---	StupidStoreMP1		MP <- R1
 641            
 642 00617 0000 DoStupidStoreMP1, .-.
 643 00620 7200 	CLA
 644 00621 1021 	TAD StupidR1
 645 00622 3027 	DCA StupidMP
 646 00623 5617 	JMP I DoStupidStoreMP1
 647            
 648            /---	StupidStorePC0		Jump to address in R0
 649            /
 650            /	Also, return address on stack must be cleaned up.
 651            
 652 00624 0000 DoStupidStorePC0, .-.
 653 00625 5420 	JMP I StupidR0
 654            
 655            /---	StupidStoreRP0		RP <- R0
 656            
 657 00626 0000 DoStupidStoreRP0, .-.
 658 00627 7200 	CLA
 659 00630 1020 	TAD StupidR0
 660 00631 3030 	DCA StupidRP
 661 00632 5626 	JMP I DoStupidStoreRP0
 662            
 663            /---	StupidSwap1	SwapReg <- R0, R0 <- R1, R1 <- SwapReg
 664            /
 665            /	Swaps the top two items on the stack.
 666            
 667 00633 0000 DoStupidSwap1, .-.
 668 00634 7200 	CLA
 669 00635 1020 	TAD StupidR0
 670 00636 3024 	DCA StupidSwapReg
 671 00637 1021 	TAD StupidR1
 672 00640 3020 	DCA StupidR0
 673 00641 1024 	TAD StupidSwapReg
 674 00642 3021 	DCA StupidR1
 675 00643 5633 	JMP I DoStupidSwap1
 676            
 677            /---	StupidSwap2	SwapReg <- R1, R1 <- R2, R2 <- SwapReg
 678            /
 679            /	Swaps the top two items on the stack.
 680            
 681 00644 0000 DoStupidSwap2, .-.
 682 00645 7200 	CLA
 683 00646 1021 	TAD StupidR1
 684 00647 3024 	DCA StupidSwapReg
 685 00650 1022 	TAD StupidR2
 686 00651 3021 	DCA StupidR1
 687 00652 1024 	TAD StupidSwapReg
 688 00653 3022 	DCA StupidR2
 689 00654 5644 	JMP I DoStupidSwap2
 690            
 691            /---	StupidSwap3	SwapReg <- R2, R2 <- R3, R3 <- SwapReg
 692            /
 693            /	Swaps the top two items on the stack.
 694            
 695 00655 0000 DoStupidSwap3, .-.
 696 00656 7200 	CLA
 697 00657 1022 	TAD StupidR2
 698 00660 3024 	DCA StupidSwapReg
 699 00661 1023 	TAD StupidR3
 700 00662 3022 	DCA StupidR2
 701 00663 1024 	TAD StupidSwapReg
 702 00664 3023 	DCA StupidR3
 703 00665 5655 	JMP I DoStupidSwap3
 704            
 705            /---	MSQE		M: ( -> Flag )
 706            /			R: ( -> )
 707            /
 708            /	Machine-specific code for ?EMIT. Tests to see if the console
 709            /	is ready to accept a character, pushing the result on the
 710            /	math stack. If the console can accept a character, a non-zero
 711            /	flag is pushed. Otherwise, a zero flag is pushed.
 712            
 713 00666 2027 MSQE,	ISZ StupidMP	/ Make space for the flag
 714            
 715 00667 7201 	CLA IAC		/ Assume we'll skip (it can print)
 716 00670 6041 	TSF
 717 00671 7200 	CLA		/ It's not ready
 718            
 719 00672 3427 	DCA I StupidMP	/ Store the flag
 720            
 721 00673 5431 	JMP I Next	/ Next word
 722            
 723            /---	MSE		M: ( Character -> )
 724            /			R: ( -> )
 725            /
 726            /	Machine specific code for (EMIT). Puts a character on the
 727            /	console then drops it from the math stack.
 728            
 729 00674 7200 MSE,	CLA		/ Get the character
 730 00675 1427 	TAD I StupidMP
 731            
 732 00676 6044 	TPC		/ Print the character
 733            
 734 00677 7200 	CLA		/ Drop one from the math stack
 735 00700 1027 	TAD StupidMP
 736 00701 7041 	CMA IAC;CMA
     00702 7040 
 737 00703 3027 	DCA StupidMP
 738            
 739 00704 5431 	JMP I Next	/ Next
 740            
 741            /---	MSQK		M: ( -> Flag )
 742            /			R: ( -> )
 743            /
 744            /	Machine specific code for ?KEY. Tests the console to see if a
 745            /	character is available. If so, a non-zero flag is pushed. 
 746            /	Otherwise a zero flag is pushed.
 747            
 748 00705 2027 MSQK,	ISZ StupidMP	/ Make space for the flag
 749            
 750 00706 7201 	CLA IAC		/ Assume we'll skip (it's ready)
 751 00707 6031 	KSF
 752 00710 7200 	CLA		/ Didn't skip; it's not.
 753            
 754 00711 3427 	DCA I StupidMP	/ Store the flag
 755            
 756 00712 5431 	JMP I Next	/ Next
 757            
 758            /---	MSK		M: ( -> Character )
 759            /			R:
 760            /
 761            /	Machine specific code for (KEY). Reads a character from the
 762            /	console, pushing it on the math stack.
 763            
 764 00713 2027 MSK,	ISZ StupidMP	/ Make space for the character
 765 00714 6036 	KRB		/ Get the character
 766 00715 3427 	DCA I StupidMP	/ Store the character
 767 00716 5431 	JMP I Next	/ Next
 768            
 769            /---	MSBYE
 770            /
 771            /
 772            /	Machine-specific code for BYE. Since we don't have an OS, we
 773            /	just halt and then restart if anyone's foolish enough to restart.
 774            
 775 00717 7402 MSBYE,	HLT
 776 00720 5721 	JMP I MSBYE1
 777 00721 0200 MSBYE1,	Reset
 778            

 . . . 

 779            	EJECT
 780            
 781            /	Space for the THIRD stacks. We're going to grow the
 782            /	math stack up and the return stack down so that they
 783            /	can dynamically share a block of space.
 784            
 785            MathStackBottom,
 786 00722 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     00723 0000 
     00724 0000 
     00725 0000 
     00726 0000 
     00727 0000 
     00730 0000 
     00731 0000 
     00732 0000 
     00733 0000 
     00734 0000 
     00735 0000 
     00736 0000 
     00737 0000 
     00740 0000 
     00741 0000 
 787 00742 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     00743 0000 
     00744 0000 
     00745 0000 
     00746 0000 
     00747 0000 
     00750 0000 
     00751 0000 
     00752 0000 
     00753 0000 
     00754 0000 
     00755 0000 
     00756 0000 
     00757 0000 
     00760 0000 
     00761 0000 
 788 00762 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     00763 0000 
     00764 0000 
     00765 0000 
     00766 0000 
     00767 0000 
     00770 0000 
     00771 0000 
     00772 0000 
     00773 0000 
     00774 0000 
     00775 0000 
     00776 0000 
     00777 0000 
     01000 0000 
     01001 0000 
 789 01002 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     01003 0000 
     01004 0000 
     01005 0000 
     01006 0000 
     01007 0000 
     01010 0000 
     01011 0000 
     01012 0000 
     01013 0000 
     01014 0000 
     01015 0000 
     01016 0000 
     01017 0000 
     01020 0000 
     01021 0000 
 790 01022 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     01023 0000 
     01024 0000 
     01025 0000 
     01026 0000 
     01027 0000 
     01030 0000 
     01031 0000 
     01032 0000 
     01033 0000 
     01034 0000 
     01035 0000 
     01036 0000 
     01037 0000 
     01040 0000 
     01041 0000 
 791 01042 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     01043 0000 
     01044 0000 
     01045 0000 
     01046 0000 
     01047 0000 
     01050 0000 
     01051 0000 
     01052 0000 
     01053 0000 
     01054 0000 
     01055 0000 
     01056 0000 
     01057 0000 
     01060 0000 
     01061 0000 
 792 01062 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     01063 0000 
     01064 0000 
     01065 0000 
     01066 0000 
     01067 0000 
     01070 0000 
     01071 0000 
     01072 0000 
     01073 0000 
     01074 0000 
     01075 0000 
     01076 0000 
     01077 0000 
     01100 0000 
     01101 0000 
 793 01102 0000 	0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
     01103 0000 
     01104 0000 
     01105 0000 
     01106 0000 
     01107 0000 
     01110 0000 
     01111 0000 
     01112 0000 
     01113 0000 
     01114 0000 
     01115 0000 
     01116 0000 
     01117 0000 
     01120 0000 
     01121 0000 
 794            ReturnStackBottom,
 795            StupidRamBase,
 796            	PAGE

 . . . 

 797            	EJECT
 798            
 799            / ----------------------------------------------------------------------
 800            / 
 801            / 		BASIC WORDS
 802            / 
 803            / These words are the basic FORTH system. Different projects extend
 804            / this by hanging words off the base system.
 805            / 
 806            / These words must begin the dictionary so the base words don't have
 807            / to know anything about the project-specific words.
 808            / 
 809            / The last word of the base system will always be ABORT. The first
 810            / word of the project-specific system should specify ABORT as its
 811            / previous word.
 812            / 
 813            / The project-specific words must include ?KEY, KEY, and EMIT.
 814            / 
 815            / Revisions:	04/21/97 RLI - Changed the flags byte to be a flags longword.
 816            / 		04/22/01 RLI - Added SYSCALL and DROP opcodes.
 817            / 		05/03/01 RLI - Glib reg- VM ops encourage backwards
 818            / 		               subtracts. Now I have to look at them all.
 819            / 		               Oops. Fixing it breaks control over growing
 820            / 		               the math stack direction! reg- and reg+ will
 821            / 		               now do reverse subtracts when appropriate.
 822            / 		               I can either add a SWAP operation or special
 823            / 		               case reg-. I think I'll add SWAP; making a
 824            / 		               reverse minus would be more efficient (since
 825            / 		               it's only used by reg-), but we're not
 826            / 		               interested in efficiency.
 827            / 		05/10/01 RLI - ($) incorrectly skipped count byte.
 828            / 
 829            / 		               BTW, I've realized that .NYBBLES assumes
 830            / 		               word size is an even multiple of four
 831            / 		               bits. There'll be no 18-bit THIRD until
 832            / 		               I figure out what to do about that.
 833            / 
 834            / 		               Fixed a bunch of bogus blank line comments.
 835            / 		               This hadn't been a problem on DOS with ^M^J
 836            / 		               line terminators, but popped up when things
 837            / 		               were moved to Unix.
 838            / 
 839            / ----------------------------------------------------------------------
 840            / ----
 841            / 
 842            / Primitives
 843            / 
 844            / These words make up the absolute core of the FORTH system. For most
 845            / of them, I just can't think of any way to turn them into high-level
 846            / FORTH words.
 847            / 
 848            / ----
 849            
 850            
 851            / ----	(NEXT) -- word # 0
 852            
 853            W0Name,
 854            
 855            	/ stringengize( (NEXT) )
 856 01200 0050 50
 857 01201 0116 116
 858 01202 0105 105
 859 01203 0130 130
 860 01204 0124 124
 861 01205 0051 51
 862            
 863 01206 0106 	.+100-W0Name
 864 01207 0000 	0		/ First word
 865            W0CFA,
 866 01210 0000 	W0CFA-.		/ (NEXT)
 867            W0PFA,
 868            / (NEXT)				M: ( -> )
 869            / 				R: ( -> )
 870            / 
 871            / This is the "inner interpreter". It knows how to fetch and execute
 872            / the next FORTH word. You should probably not refer to this word in
 873            / your FORTH code as it is highly unlikely that it will prove useful
 874            / (most FORTH systems don't provide a header for this word).
 875            / 
 876            / Revisions:
 877            / 
 878            / 07/29/99 RLI - code version
 879            / 
 880            / There are actually several generally useful chunks of code included
 881            / here, because they are either useful here or there is no really
 882            / good place to put them (but they have to go _somewhere!).
 883            / 
 884            / ################################################### 
 885            / 
 886            / There isn't any really good place to describe what's going on, so
 887            / this will have to do.
 888            / 
 889            / The .mini4 files contain descriptions of the machine code needed
 890            / to implement the SCIFORTH primitives in a hypothetical assembly
 891            / language for a four-level stack machine modelled on a
 892            / traditional HP calculator. These descriptions will be compiled
 893            / into machine code for the specific processor by the appropriate
 894            / version of the QDL collator. The descriptions are intended to be
 895            / compilable in either a simple minded manner or, should someone
 896            / get really enthused in writing a QDL collator, in an optimized
 897            / manner.
 898            / 
 899            / The intent is to describe SCIFORTH in a sequence of statements
 900            / with limited stack depth. In addition to the small mini4 stack,
 901            / SCIFORTH needs a number of registers; it is assumed to be
 902            / inexpensive enough to access these registers that the mini4 code
 903            / does not need to expend a lot of effort trying to keep things on
 904            / the stack; i.e., if MP is used twice, the mini4 code assumes
 905            / that a sequence like MP@ <stuff> MP@ is preferred to a sequence
 906            / like MP@ DUP <stuff>.
 907            / 
 908            / The mini4 machine is a single-stack machine; it has only a 
 909            / math stack. The return stack is constructed by mini4 operations
 910            / on registers and memory.
 911            / 
 912            / The smallest addressable unit in SCIFORTH is the 'byte'.
 913            / SCIFORTH deals primarily in 'cells', which may be one or more
 914            / 'byte's long. There may be an additional intermediate unit on
 915            / which the machine may operate called the 'word'. A 'byte' or
 916            / 'word' may be fetched or stored to memory, but all operations in
 917            / the SCIFORTH math stack operate strictly on 'cell's. 'Byte's and
 918            / 'word's are converted to 'cell's as they are fetched and stored.
 919            / Upon storing a 'byte' or 'word', the conversion is done by
 920            / issuing the appropriate type of transaction. When fetching a
 921            / 'byte' or 'word', the value fetched may be either sign-extended
 922            / or zero-extended to form a 'cell' for use on the math stack.
 923            / 
 924            / An SCIFORTH implementation is not required to distinguish
 925            / between 'byte's, 'word's, and 'cell's. It is possible to have an
 926            / implementation with only 'cell's or an implementation with only
 927            / 'byte's and 'cell's.
 928            / 
 929            / ---------------------- MINI4 OPCODES ----------------------
 930            / 
 931            / @	( Address -> Value ) Fetch a cell from memory. 
 932            / 
 933            / !	( Value, Address -> ) Write a cell to memory.
 934            / 
 935            / @.zb	( Address -> Value ) Fetch a byte from memory and
 936            / 	zero-extend it to a cell. On machines with one-byte
 937            / 	cells, this is equivalent to @.
 938            / 
 939            / !.b	( Value, Address -> ) Write a byte to memory. On
 940            / 	machines with one-byte cells, this is equivalent to !.
 941            / 
 942            / @.sw	( Address -> Value ) Fetch a word from memory and
 943            / 	sign-extend it to a cell. On machines with one-word
 944            / 	cells, this is equivalent to @.
 945            / 
 946            / @.zw	( Address -> Value ) Fetch a word from memory and
 947            / 	sign-extend it to a cell. On machines with one-word
 948            / 	cells, this is equivalent to @.
 949            / 
 950            / !.w	( Value, Address -> ) Write a word to memory. On
 951            / 	machines with one-word cells, this is equivalent to !.
 952            / 
 953            / REG@	( -> Value ) Copy the named register to the top of the 
 954            / 	stack. The register names are described below.
 955            / 
 956            / REG!	( Value -> ) Copy the top of the stack to the
 957            / 	named register. The register names are described below.
 958            / 
 959            / +	( a, b -> a+b ) Add the top two cells on the stack,
 960            / 	leaving the result on the stack.
 961            / 
 962            / -	( a, b -> a-b ) Subtract the top two cells on the 
 963            / 	stack, leaving the result on the stack.
 964            / 
 965            / AND	( a, b -> a AND b ) Perform a bitwise AND between the
 966            / 	top two elements on the stack, leaving the result on the
 967            / 	stack.
 968            / 
 969            / OR	( a, b -> a OR b ) Perform a bitwise OR between the top
 970            / 	two elements on the stack, leaving the result on the
 971            / 	stack.
 972            / 
 973            / XOR	( a, b -> a XOR b ) Perform a bitwise XOR between the
 974            / 	top two elements on the stack, leaving the result on the
 975            / 	stack.
 976            / 
 977            / GO label ( -> ) Jump to the named label.
 978            / 
 979            / ELSEGO label ( flag -> ) Jump to the named label if the top of the
 980            / 	stack is zero.
 981            / 
 982            / <GO label ( a, b -> ) Jump to named label if a < b.
 983            / 
 984            / NEG	( a -> -a ) Form the two's complement of the cell on top
 985            / 	of the stack.
 986            / 
 987            / NOT	( a -> ~a ) Form the one's complement of the cell on top
 988            / 	of the stack.
 989            / 
 990            / <<	( a, b -> a<<b ) Shift left.
 991            / 
 992            / >>	( a, b -> a>>b ) Shift right (logical).
 993            / 
 994            / DUP	( a -> a, a ) Push a copy of the top of stack onto the
 995            / 	stack.
 996            / 
 997            / 	DROP	( a -> ) Drop something from the stack.
 998            / 
 999            / 	SYSCALL	( -> ) Escape hatch for assembly language. The math
1000            / 		stack depth is assumed not to change (this required the
1001            / 		addition of DROP).
1002            / 
1003            / ---------------------- MINI4 PSEUDOOPS -------------------------
1004            / 
1005            / ;	This pseudo-instruction informs QDL that the stack
1006            / 	should be empty. The QDL collator should issue an error
1007            / 	message if the stack is not empty. It is intended
1008            / 	primarily as a debugging aid.
1009            / 
1010            / LABEL label ( -> ) Declare a label. Note that these labels are
1011            / 	global, as opposed to the intentionally local scope of
1012            / 	QDL %LABELs.
1013            / 
1014            / #	( -> ) The rest of the line is copied to the output as a
1015            / 	comment.
1016            / 
1017            / (	( -> ) The rest of the line is skipped.
1018            / 
1019            / MP+	This word adds the FORTH math stack pointer to the cell
1020            / 	on the stack. In a system that grows the math stack
1021            / 	downward, this is equivalent to "MP@ +". In a system
1022            / 	that grows the math stack upward, this is equivalent to
1023            / 	"MP@ SWAP -". This opcode allows systems which grow the FORTH
1024            / 	math stack either way to be built from the same source
1025            / 	code; In both systems, a word is dropped from the math
1026            / 	stack by "CELLSIZE MP+ MP!".
1027            / 
1028            / MP-	This word subtracts the cell on the stack from the FORTH
1029            / 		math stack pointer. In a system that grows the math
1030            / 	stack downward, this is equivalent to "MP@ SWAP -". In a
1031            / 	system that grows the math stack upward, this is
1032            / 	equivalent to "MP@ +". This opcode allows systems which
1033            / 	grow the FORTH math stack either way to be built from
1034            / 	the same source code; in both systems, space is made for
1035            / 	an item on the math stack by "CELLSIZE MP- MP!".
1036            / 
1037            / RP+	This word adds the FORTH return stack pointer to the
1038            / 	cell on the stack. In a system that grows the return
1039            / 	stack downward, this is equivalent to "RP@ +". In a
1040            / 	system that grows the math stack upward, this is
1041            / 	equivalent to "RP@ SWAP -". This opcode allows systems which
1042            / 	grow the FORTH return stack either way to be built from
1043            / 	the same source code; in both systems, a word is dropped
1044            / 	from the return stack by "CELLSIZE RP+ RP!".
1045            / 
1046            / RP-	This word subtracts the cell on top of the stack from the
1047            / 		FORTH return stack pointer. In a system the grows the return
1048            / 	stack downward, this is equivalent to "RP@ SWAP -". In a
1049            / 	system that grows the math stack upward, this is
1050            / 	equivalent to "RP@ +". This opcode allows systems which
1051            / 	grow the FORTH return stack either way to be built from
1052            / 	the same source code; in both systems, space is made for
1053            / 	an item on the return stack by "CELLSIZE RP- RP!".
1054            / 
1055            / NEXT	Executes the next FORTH word. This is equivalent to
1056            / 	branching to Next:, below, but is given an opcode to
1057            / 	deal with the variety of possible ways in which such a
1058            / 	branch might be accomplished (for example, branching to
1059            / 	the address in the NEXT register would allow a variety
1060            / 	of Next routines to be used; perhaps one that yields in
1061            / 	a cooperative multitasking environment could be
1062            / 	provided).
1063            / 
1064            / BYTE value ( -> ) Emits a constant byte into the generated code
1065            / 	stream. This is primarily for the creation of DIGITMAP,
1066            / 	which is a pre-initialized array of bytes.
1067            / 
1068            / CELLSIZE ( -> Number of bytes in a cell ) Push the size of a
1069            / 	cell in bytes onto the stack.
1070            / 
1071            / DEFINITION ( -> Offset to definition in bytes ) Push the offset
1072            / 	from a CFA to the word's definition onto the stack.
1073            / 
1074            / 	SWAP	( a b -> b a ) Swaps the top two items on the math stack.
1075            / 
1076            / END	( -> ) Indicates the end of the CODE source. The CODE
1077            / 	compiler returns to QDL.
1078            / 
1079            / Anything else is assumed to be a literal. Yes, this means it's
1080            / not possible for there to be a syntax error. Yes, this does mean
1081            / finding typos etc. will be painful.
1082            / 
1083            / ----------------------- REGISTERS ------------------------
1084            / 
1085            / Several registers are needed for this effort. In the pseudocode
1086            / descriptions in these files, those registers are:
1087            / 
1088            / NEXT 	Contains the address of the code starting at Next:, below.
1089            / 	This is typically used as a convenience for hand-assembled
1090            / 	CODE words, as it allows such a word to exit by jumping to
1091            / 	the contents of a register rather than requiring that an
1092            / 	offset to Next: be calculated. CODE words that are part of
1093            / 	the SCIFORTH source code will typically branch to Next:
1094            / 	instead of jumping to the contents of the NEXT register.
1095            / 
1096            / 	The contents of this register are initialized by the startup
1097            / 	code. It may be re-initialized if the code moves (for
1098            / 	example, if SCIFORTH is moved from ROM to RAM in preparation
1099            / 	for re-programming the FLASH ROM containing SCIFORTH).
1100            / 
1101            / PC	Contains the machine code instruction pointer. This is
1102            / 	used to describe branches; loading a value into the PC
1103            / 	is equivalent to branching to that address.
1104            / 
1105            / 	The PC cannot be fetched; that is, PC@ is not valid.
1106            / 
1107            / IP	Contains the FORTH instruction pointer. The cell pointed to
1108            / 	by IP contains a pointer to the CFA of the next FORTH word
1109            / 	to be executed.
1110            / 
1111            / 	The startup code typically begins executing SCIFORTH by
1112            / 	loading the address of (COLD) into IP and jumping to Next:.
1113            / 
1114            / RP	Contains the return stack pointer. This is the address of
1115            / 	the last item written to the return stack in memory. The
1116            / 	return stack actually contains two more items in the
1117            / 	R2 and R1 registers, described below.
1118            / 
1119            / 	RP is decremented before an item is moved from the return
1120            / 	stack cache to memory. It is incremented after an item is
1121            / 	moved from memory to the return stack cache.
1122            / 
1123            / MP	Contains the math stack pointer. This is the address of
1124            / 	the last item written to the math stack in memory. The
1125            / 	math stack actually contains two more items in the M2 and
1126            / 	M1 registers, described below.
1127            / 
1128            / 	MP is decremented before an item is moved from the math
1129            / 	stack cache to memory. It is incremented after an item is
1130            / 	moved from memory to the math stack cache.
1131            / 
1132            / CFA	Contains the address of the CFA of the FORTH word currently
1133            / 	being executed. This is calculated by Next: as part of
1134            / 	finding the next word to execute and is used by such words
1135            / 	as (VAR) and (CONSTANT), which need to be able to find the
1136            / 	definition of the current word being executed.
1137            / 
1138            / InitialMP Contains the initial value for the math stack pointer;
1139            / 	that is, the address of the cell immediately above the
1140            / 	memory region in which the math stack is to reside. It is
1141            / 	initialized by the startup code before FORTH code begins
1142            / 	to be executed.
1143            / 
1144            / InitialRP Contains the initial value for the return stack pointer;
1145            / 	that is, the address of the cell immediately above the
1146            / 	memory region in which the return stack is to reside. It is
1147            / 	initialized by the startup code before FORTH code begins
1148            / 	to be executed.
1149            / 
1150            / There are two additional registers which are not needed by the core
1151            / SCIFORTH dictionary, but are useful for implementations that need to
1152            / be moved around in memory (such as copying themselves from ROM to
1153            / RAM). They are:
1154            / 
1155            / InitialDP Contains the initial value for the dictionary pointer;
1156            / 	that is, the address of the cell immediately following the
1157            / 	current dictionary. This is initialized by the startup code
1158            / 	before FORTH code begins to be executed.
1159            / 
1160            / InitialLAST Contains the initial value for the pointer to the CFA of
1161            / 	the last word in the dictionary. This is initialized by the
1162            / 	startup code before FORTH code begins to be executed.
1163            / 
1164            / ################################# 
1165            / 
1166            / This file contains several snippets of code:
1167            / 
1168            / Next	Code to fetch the pointer to the next word to be executed
1169            / Next_A	Code to execute the word after the pointer has been fetched
1170            / 
1171            / ################################ 
1172            / 
1173            / Next
1174            / 
1175            / This code fetches the pointer to the next word to be executed. It
1176            / falls through to Next_A, which jumps to the machine code which knows
1177            / how to execute the word.
1178            / 
1179            SL1,			/ LABEL Next
1180            / Fetch the offset to the CFA of the word to be executed next and
1181            / relocate it to form the address of the CFA.
1182 01211 4441 	JMS I StupidFetchIP0		/ IP@
1183 01212 4435 	JMS I StupidFetch0		/ @
1184 01213 4442 	JMS I StupidFetchIP1		/ IP@
1185 01214 4471 	JMS I StupidPlus1			/ +
1186 01215 4477 	JMS I StupidStoreCFA0		/ CFA!
1187            / Advance the IP past the cell just fetched.
1188 01216 4441 	JMS I StupidFetchIP0		/ IP@
1189 01217 4461 	JMS I StupidLiteral1		/ 1
1190 01220 0001 	1
1191 01221 4471 	JMS I StupidPlus1			/ +
1192 01222 4500 	JMS I StupidStoreIP0		/ IP!
1193            / Next_A
1194            / 
1195            / This code takes the pointer to the next word to be executed in CFA
1196            / and uses it to locate and enter the machine code which knows how to
1197            / execute the word. This code is used by both (NEXT) and EXEC.
1198            SL2,			/ LABEL Next_A
1199            / Fetch and relocate the pointer to the CFA of the word that knows
1200            / how to execute this word.
1201 01223 4437 	JMS I StupidFetchCFA0		/ CFA@
1202 01224 4435 	JMS I StupidFetch0		/ @
1203 01225 4440 	JMS I StupidFetchCFA1		/ CFA@
1204 01226 4471 	JMS I StupidPlus1			/ +
1205            / Form a pointer to the code contained in that word's definition.
1206 01227 4461 	JMS I StupidLiteral1		/ 1
1207 01230 0001 	1
1208 01231 4471 	JMS I StupidPlus1			/ +
1209            / Jump to the code that knows how to execute this word.
1210 01232 4503 	JMS I StupidStorePC0		/ PC!
1211            
1212            
1213            / ----	EXEC -- word # 3
1214            
1215            W3Name,
1216            
1217            	/ stringengize( EXEC )
1218 01233 0105 105
1219 01234 0130 130
1220 01235 0105 105
1221 01236 0103 103
1222            
1223 01237 0004 	.+0-W3Name
1224 01240 0031 	W3CFA-W0CFA
1225            W3CFA,
1226 01241 0000 	W3CFA-.		/ EXEC
1227            W3PFA,
1228            / EXEC - Execute a word whose address is on top of the math stack.
1229            / 
1230            / M: ( cfa -> [depends on word executed] )
1231            / R: ( -> )
1232            / 
1233            / This word needs intimate knowledge of (NEXT) in order to work
1234            / correctly. It works by stuffing the address of the word to be
1235            / executed where (NEXT) puts it after relocating it and branching
1236            / to the place in (NEXT) where the transfer is made. In terms of our
1237            / hyphothetical skeleton machine, that means copying the top of the
1238            / math stack to CFA and jumping to Next_A:
1239            / 
1240            / Revisions:
1241            / 07/29/99 RLI - code version
1242            / Copy the top of the math stack to CFA.
1243 01242 4447 	JMS I StupidFetchMP0		/ MP@
1244 01243 4435 	JMS I StupidFetch0		/ @
1245 01244 4477 	JMS I StupidStoreCFA0		/ CFA!
1246            / Pop the CFA address from the math stack.
1247 01245 4460 	JMS I StupidLiteral0		/ 1
1248 01246 0001 	1
1249 01247 4450 	JMS I StupidFetchMP1		/ MP@
1250 01250 4505 	JMS I StupidSwap1		/ SWAP
1251 01251 4463 	JMS I StupidMinus1		/ -
1252 01252 4501 	JMS I StupidStoreMP0		/ MP!
1253            / Branch to Next_A
1254 01253 5223 	JMP SL2		/ GO Next_A
1255            
1256            
1257            / ----	(:) -- word # 4
1258            
1259            W4Name,
1260            
1261            	/ stringengize( (:) )
1262 01254 0050 50
1263 01255 0072 72
1264 01256 0051 51
1265            
1266 01257 0003 	.+0-W4Name
1267 01260 0020 	W4CFA-W3CFA
1268            W4CFA,
1269 01261 0000 	W4CFA-.		/ (:)
1270            W4PFA,
1271            / (:) - Enter a FORTH word	M: ( -> )
1272            / 				R: ( -> IP )
1273            / 
1274            / This word contains machine code which knows how to execute a FORTH
1275            / word. Executing a FORTH word consists of saving the current IP on
1276            / the stack (that's the address to which we'll return after this FORTH
1277            / word is executing) and replacing IP by the address of the current
1278            / word's definition. The address of the current word's header is
1279            / conveniently left for us in CFA by NEXT.
1280            / 
1281            / Revisions:
1282            / 07/29/99 RLI - code version
1283            / Make space for IP on the return stack
1284 01262 4460 	JMS I StupidLiteral0		/ 1
1285 01263 0001 	1
1286 01264 4455 	JMS I StupidFetchRP1		/ RP@
1287 01265 4505 	JMS I StupidSwap1		/ SWAP
1288 01266 4463 	JMS I StupidMinus1		/ -
1289 01267 4504 	JMS I StupidStoreRP0		/ RP!
1290            / Store IP on the return stack.
1291 01270 4441 	JMS I StupidFetchIP0		/ IP@
1292 01271 4455 	JMS I StupidFetchRP1		/ RP@
1293 01272 4475 	JMS I StupidStore1		/ !
1294            / Put the address of the current word's definition in IP.
1295 01273 4437 	JMS I StupidFetchCFA0		/ CFA@
1296 01274 4461 	JMS I StupidLiteral1		/ 1
1297 01275 0001 	1
1298 01276 4471 	JMS I StupidPlus1			/ +
1299 01277 4500 	JMS I StupidStoreIP0		/ IP!
1300 01300 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1301 01301 4503 	JMS I StupidStorePC0		/ PC!
1302            
1303            
1304            / ----	(;) -- word # 5
1305            
1306            W5Name,
1307            
1308            	/ stringengize( (;) )
1309 01302 0050 50
1310 01303 0073 73
1311 01304 0051 51
1312            
1313 01305 0003 	.+0-W5Name
1314 01306 0026 	W5CFA-W4CFA
1315            W5CFA,
1316 01307 0000 	W5CFA-.		/ (;)
1317            W5PFA,
1318            / (;) - Terminate execution of a FORTH word
1319            / 
1320            / M: ( -> )
1321            / R: ( Return address -> )
1322            / 
1323            / This word executes the end of a FORTH word. It pops the IP from the
1324            / return stack and begins execution there.
1325            / 
1326            / Revisions:
1327            / 07/29/99 RLI - code version.
1328            / Copy the top of the return stack into IP.
1329 01310 4454 	JMS I StupidFetchRP0		/ RP@
1330 01311 4435 	JMS I StupidFetch0		/ @
1331 01312 4500 	JMS I StupidStoreIP0		/ IP!
1332            / Drop the return address from the return stack.
1333 01313 4460 	JMS I StupidLiteral0		/ 1
1334 01314 0001 	1
1335 01315 4455 	JMS I StupidFetchRP1		/ RP@
1336 01316 4471 	JMS I StupidPlus1			/ +
1337 01317 4504 	JMS I StupidStoreRP0		/ RP!
1338 01320 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1339 01321 4503 	JMS I StupidStorePC0		/ PC!
1340            
1341            
1342            / ----	(CONSTANT) -- word # 6
1343            
1344            W6Name,
1345            
1346            	/ stringengize( (CONSTANT) )
1347 01322 0050 50
1348 01323 0103 103
1349 01324 0117 117
1350 01325 0116 116
1351 01326 0123 123
1352 01327 0124 124
1353 01330 0101 101
1354 01331 0116 116
1355 01332 0124 124
1356 01333 0051 51
1357            
1358 01334 0012 	.+0-W6Name
1359 01335 0027 	W6CFA-W5CFA
1360            W6CFA,
1361 01336 0000 	W6CFA-.		/ (CONSTANT)
1362            W6PFA,
1363            / (CONSTANT) - Execute a constant
1364            / 
1365            / M: ( -> Whatever's in the first cell of the word's definition )
1366            / R: ( -> )
1367            / 
1368            / This word contains the machine code which knows how to execute a
1369            / CONSTANT. Executing a CONSTANT consists of taking the first cell
1370            / of the CONSTANT's definition and pushing it on the math stack.
1371            / 
1372            / NEXT conveniently leaves the address of the CONSTANT's header in CFA.
1373            / 
1374            / Revisions:
1375            / 07/29/99 RLI - code version.
1376            / Make space on the math stack
1377 01337 4460 	JMS I StupidLiteral0		/ 1
1378 01340 0001 	1
1379 01341 4450 	JMS I StupidFetchMP1		/ MP@
1380 01342 4471 	JMS I StupidPlus1			/ +
1381 01343 4501 	JMS I StupidStoreMP0		/ MP!
1382            / Calculate the address of the first cell of the definition.
1383 01344 4437 	JMS I StupidFetchCFA0		/ CFA@
1384 01345 4461 	JMS I StupidLiteral1		/ 1
1385 01346 0001 	1
1386 01347 4471 	JMS I StupidPlus1			/ +
1387            / Copy the first cell of the definition into the top of the math
1388            / stack.
1389 01350 4435 	JMS I StupidFetch0		/ @
1390 01351 4450 	JMS I StupidFetchMP1		/ MP@
1391 01352 4475 	JMS I StupidStore1		/ !
1392 01353 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1393 01354 4503 	JMS I StupidStorePC0		/ PC!
1394            
1395            
1396            / ----	(VAR) -- word # 7
1397            
1398            W7Name,
1399            
1400            	/ stringengize( (VAR) )
1401 01355 0050 50
1402 01356 0126 126
1403 01357 0101 101
1404 01360 0122 122
1405 01361 0051 51
1406            
1407 01362 0005 	.+0-W7Name
1408 01363 0026 	W7CFA-W6CFA
1409            W7CFA,
1410 01364 0000 	W7CFA-.		/ (VAR)
1411            W7PFA,
1412            / (VAR) - Code which knows how to execute a VAR
1413            / 
1414            / M: ( -> The address of the word's definition )
1415            / R: ( -> )
1416            / 
1417            / This word contains the machine code which knows how to execute a
1418            / VARiable. Execution of a VARiable consists of pushing the address of
1419            / the VARiable's definition onto the math stack.
1420            / 
1421            / NEXT conveniently leaves the address of the VARiable's header in
1422            / CFA.
1423            / 
1424            / Revisions:
1425            / 07/29/99 RLI - code version.
1426            / Make space on the math stack for one cell.
1427 01365 4460 	JMS I StupidLiteral0		/ 1
1428 01366 0001 	1
1429 01367 4450 	JMS I StupidFetchMP1		/ MP@
1430 01370 4471 	JMS I StupidPlus1			/ +
1431 01371 4501 	JMS I StupidStoreMP0		/ MP!
1432            / Calculate the address of the current word's definition, leaving
1433            / the result in the top of the math stack.
1434 01372 4437 	JMS I StupidFetchCFA0		/ CFA@
1435 01373 4461 	JMS I StupidLiteral1		/ 1
1436 01374 0001 	1
1437 01375 4471 	JMS I StupidPlus1			/ +
1438 01376 4450 	JMS I StupidFetchMP1		/ MP@
1439 01377 4475 	JMS I StupidStore1		/ !
1440 01400 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1441 01401 4503 	JMS I StupidStorePC0		/ PC!
1442            
1443            
1444            / ----	(BRANCH) -- word # 8
1445            
1446            W8Name,
1447            
1448            	/ stringengize( (BRANCH) )
1449 01402 0050 50
1450 01403 0102 102
1451 01404 0122 122
1452 01405 0101 101
1453 01406 0116 116
1454 01407 0103 103
1455 01410 0110 110
1456 01411 0051 51
1457            
1458 01412 0010 	.+0-W8Name
1459 01413 0030 	W8CFA-W7CFA
1460            W8CFA,
1461 01414 0000 	W8CFA-.		/ (BRANCH)
1462            W8PFA,
1463            / (BRANCH) - Branch to a word
1464            / 
1465            / M: ( -> )
1466            / R: ( -> )
1467            / 
1468            / This word contains the machine code to execute a branch. A branch is
1469            / executed by adding the offset in the code following the reference 
1470            / to this word to the IP. This word is generally not referred to
1471            / directly by users typing in code; the references are built
1472            / implicitly by words like IF, UNTIL, LOOP, etc.
1473            / 
1474            / This code is also used as a utility routine by a variety of other
1475            / low-level words. They enter at the label pBranch:
1476            / 
1477            / Revisions:
1478            / 07/29/99 RLI - code version
1479            SL9,			/ LABEL pBranch
1480            / Fetch the branch offset
1481 01415 4441 	JMS I StupidFetchIP0		/ IP@
1482 01416 4435 	JMS I StupidFetch0		/ @
1483            / Relocate the offset to form the address to which it refers
1484 01417 4442 	JMS I StupidFetchIP1		/ IP@
1485 01420 4471 	JMS I StupidPlus1			/ +
1486            / Start executing there
1487 01421 4500 	JMS I StupidStoreIP0		/ IP!
1488 01422 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1489 01423 4503 	JMS I StupidStorePC0		/ PC!
1490            
1491            
1492            / ----	(0BRANCH) -- word # 10
1493            
1494            W10Name,
1495            
1496            	/ stringengize( (0BRANCH) )
1497 01424 0050 50
1498 01425 0060 60
1499 01426 0102 102
1500 01427 0122 122
1501 01430 0101 101
1502 01431 0116 116
1503 01432 0103 103
1504 01433 0110 110
1505 01434 0051 51
1506            
1507 01435 0011 	.+0-W10Name
1508 01436 0023 	W10CFA-W8CFA
1509            W10CFA,
1510 01437 0000 	W10CFA-.		/ (0BRANCH)
1511            W10PFA,
1512            / (0BRANCH) - Branch if the top of stack is zero.
1513            / 
1514            / M: ( flag -> )
1515            / R: ( -> )
1516            / 
1517            / This word knows how to conditionally branch based on the top of the
1518            / stack. If the top of stack is zero, the cell  following the reference
1519            / to (0BRANCH) is added to IP. Otherwise, IP is simply incremented past
1520            / the offset.
1521            / 
1522            / This word is typically not referred to by users typing code.
1523            / References to it are generated implicitly by words like IF.
1524            / 
1525            / The branch is performed by entering (BRANCH) at pBranch.
1526            / 
1527            / Revisions:
1528            / 07/29/99 RLI - code version
1529            / Grab the flag from the math stack and pop the math stack.
1530 01440 4447 	JMS I StupidFetchMP0		/ MP@
1531 01441 4435 	JMS I StupidFetch0		/ @
1532 01442 4461 	JMS I StupidLiteral1		/ 1
1533 01443 0001 	1
1534 01444 4451 	JMS I StupidFetchMP2		/ MP@
1535 01445 4506 	JMS I StupidSwap2		/ SWAP
1536 01446 4464 	JMS I StupidMinus2		/ -
1537 01447 4502 	JMS I StupidStoreMP1		/ MP!
1538            / If the flag is zero, branch.
1539 01450 4434 	JMS I StupidElseGo0		/ ELSEGO pBranch
1540 01451 1415 	SL9
1541            / Otherwise, skip the offset and continue.
1542 01452 4441 	JMS I StupidFetchIP0		/ IP@
1543 01453 4461 	JMS I StupidLiteral1		/ 1
1544 01454 0001 	1
1545 01455 4471 	JMS I StupidPlus1			/ +
1546 01456 4500 	JMS I StupidStoreIP0		/ IP!
1547 01457 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1548 01460 4503 	JMS I StupidStorePC0		/ PC!
1549            
1550            
1551            / ----	($) -- word # 11
1552            
1553            W11Name,
1554            
1555            	/ stringengize( ($) )
1556 01461 0050 50
1557 01462 0044 44
1558 01463 0051 51
1559            
1560 01464 0003 	.+0-W11Name
1561 01465 0027 	W11CFA-W10CFA
1562            W11CFA,
1563 01466 0000 	W11CFA-.		/ ($)
1564            W11PFA,
1565            / ($) - Word which knows how to execute a string
1566            / 
1567            / M: ( -> Address of word's definition, length of string )
1568            / R: ( -> )
1569            / 
1570            / This word executes a string variable. It puts the address of the
1571            / first character of the string and the string's length on the
1572            / math stack. (NEXT) conveniently leaves the address of the string's
1573            / CFA in CFA.
1574            / 
1575            / Revisions:
1576            / 07/29/99 RLI - code version.
1577            / 	05/10/01 RLI - Forgot to go to the word's definition before
1578            / 	               skipping the count byte.
1579            / Make space on the math stack for two cells.
1580 01467 4460 	JMS I StupidLiteral0		/ 1
1581 01470 0001 	1
1582 01471 4433 	JMS I StupidDup1			/ DUP
1583 01472 4471 	JMS I StupidPlus1			/ +
1584 01473 4450 	JMS I StupidFetchMP1		/ MP@
1585 01474 4471 	JMS I StupidPlus1			/ +
1586 01475 4501 	JMS I StupidStoreMP0		/ MP!
1587            / Calculate the address of the word's definition and fetch the length
1588            / byte from it into the top of the math stack.
1589 01476 4437 	JMS I StupidFetchCFA0		/ CFA@
1590 01477 4461 	JMS I StupidLiteral1		/ 1
1591 01500 0001 	1
1592 01501 4471 	JMS I StupidPlus1			/ +
1593            				/ @.zb
1594 01502 4435 	JMS I StupidFetch0		/ @
1595 01503 4450 	JMS I StupidFetchMP1		/ MP@
1596 01504 4475 	JMS I StupidStore1		/ !
1597            / Calculate the address of the start of the string data, leaving the
1598            / result in the second of the math stack.
1599 01505 4437 	JMS I StupidFetchCFA0		/ CFA@
1600 01506 4461 	JMS I StupidLiteral1		/ 1
1601 01507 0001 	1
1602 01510 4471 	JMS I StupidPlus1			/ +
1603 01511 4461 	JMS I StupidLiteral1		/ 1
1604 01512 0001 	1
1605 01513 4471 	JMS I StupidPlus1			/ +
1606 01514 4461 	JMS I StupidLiteral1		/ 1
1607 01515 0001 	1
1608 01516 4451 	JMS I StupidFetchMP2		/ MP@
1609 01517 4506 	JMS I StupidSwap2		/ SWAP
1610 01520 4464 	JMS I StupidMinus2		/ -
1611 01521 4475 	JMS I StupidStore1		/ !
1612 01522 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1613 01523 4503 	JMS I StupidStorePC0		/ PC!
1614            / ----
1615            / 
1616            / Fetches and stores
1617            / 
1618            / ----
1619            
1620            
1621            / ----	@ -- word # 12
1622            
1623            W12Name,
1624            
1625            	/ stringengize( @ )
1626 01524 0100 100
1627            
1628 01525 0001 	.+0-W12Name
1629 01526 0041 	W12CFA-W11CFA
1630            W12CFA,
1631 01527 0000 	W12CFA-.		/ @
1632            W12PFA,
1633            / @ - Longword fetch
1634            / 
1635            / M: ( a -> b )
1636            / R: ( -> )
1637            / 
1638            / a is used as an address to fetch b.
1639            / 
1640            / Revisions:
1641            / 07/29/99 RLI - code version
1642            / Fetch a from the math stack
1643 01530 4447 	JMS I StupidFetchMP0		/ MP@
1644 01531 4435 	JMS I StupidFetch0		/ @
1645            / Fetch the cell pointed to by a
1646 01532 4435 	JMS I StupidFetch0		/ @
1647            / Replace a with b in the math stack
1648 01533 4450 	JMS I StupidFetchMP1		/ MP@
1649 01534 4475 	JMS I StupidStore1		/ !
1650 01535 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1651 01536 4503 	JMS I StupidStorePC0		/ PC!
1652            
1653            
1654            / ----	B@ -- word # 13
1655            
1656            W13Name,
1657            
1658            	/ stringengize( B@ )
1659 01537 0102 102
1660 01540 0100 100
1661            
1662 01541 0002 	.+0-W13Name
1663 01542 0014 	W13CFA-W12CFA
1664            W13CFA,
1665 01543 0000 	W13CFA-.		/ B@
1666            W13PFA,
1667            / B@ - Byte fetch
1668            / 
1669            / M: ( a -> b )
1670            / R: ( -> )
1671            / 
1672            / a is used as an address to fetch b. b is an unsigned byte; it's
1673            / zero-extended to a cell.
1674            / 
1675            / Revisions:
1676            / 07/29/96 RLI - Modified for new register usage
1677            / 07/29/99 RLI - code version.
1678            / Fetch the address of the byte from the math stack.
1679 01544 4447 	JMS I StupidFetchMP0		/ MP@
1680 01545 4435 	JMS I StupidFetch0		/ @
1681            / Fetch and zero-extend the byte
1682            				/ @.zb
1683 01546 4435 	JMS I StupidFetch0		/ @
1684            / Replace the address in the math stack with the byte
1685 01547 4450 	JMS I StupidFetchMP1		/ MP@
1686 01550 4475 	JMS I StupidStore1		/ !
1687 01551 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1688 01552 4503 	JMS I StupidStorePC0		/ PC!
1689            
1690            
1691            / ----	W@ -- word # 14
1692            
1693            W14Name,
1694            
1695            	/ stringengize( W@ )
1696 01553 0127 127
1697 01554 0100 100
1698            
1699 01555 0002 	.+0-W14Name
1700 01556 0014 	W14CFA-W13CFA
1701            W14CFA,
1702 01557 0000 	W14CFA-.		/ W@
1703            W14PFA,
1704            / W@ - word fetch
1705            / 
1706            / M: ( a -> b )
1707            / R: ( -> )
1708            / 
1709            / a is used as an address to fetch b. b is an unsigned word; it's
1710            / zero-extended to a cell.
1711            / 
1712            / Revisions:
1713            / 07/30/99 RLI - code version
1714            / Fetch the address from the math stack
1715 01560 4447 	JMS I StupidFetchMP0		/ MP@
1716 01561 4435 	JMS I StupidFetch0		/ @
1717            / Fetch and zeroextend the word
1718            					/ @.zw -> @
1719 01562 4435 	JMS I StupidFetch0		/ @
1720            / Replace the address with the word on the math stack
1721 01563 4450 	JMS I StupidFetchMP1		/ MP@
1722 01564 4475 	JMS I StupidStore1		/ !
1723 01565 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1724 01566 4503 	JMS I StupidStorePC0		/ PC!
1725            
1726            
1727            / ----	CVTW@ -- word # 15
1728            
1729            W15Name,
1730            
1731            	/ stringengize( CVTW@ )
1732 01567 0103 103
1733 01570 0126 126
1734 01571 0124 124
1735 01572 0127 127
1736 01573 0100 100
1737            
1738 01574 0005 	.+0-W15Name
1739 01575 0017 	W15CFA-W14CFA
1740            W15CFA,
1741 01576 0000 	W15CFA-.		/ CVTW@
1742            W15PFA,
1743            / CVTW@ - Convert word fetch
1744            / 
1745            / M: ( a -> b )
1746            / R: ( -> )
1747            / 
1748            / a is used as an address to fetch b. b is a signed word; it's
1749            / sign-extended to a cell.
1750            / 
1751            / Revisions:
1752            / 
1753            / 07/29/99 RLI - code version
1754            / Fetch the address from which the word is to be fetched.
1755 01577 4447 	JMS I StupidFetchMP0		/ MP@
1756 01600 4435 	JMS I StupidFetch0		/ @
1757            / Fetch the word and sign extend it
1758            					/ @.sw -> @
1759 01601 4435 	JMS I StupidFetch0		/ @
1760            / Replace a with b
1761 01602 4450 	JMS I StupidFetchMP1		/ MP@
1762 01603 4475 	JMS I StupidStore1		/ !
1763 01604 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1764 01605 4503 	JMS I StupidStorePC0		/ PC!
1765            
1766            
1767            / ----	! -- word # 16
1768            
1769            W16Name,
1770            
1771            	/ stringengize( ! )
1772 01606 0041 41
1773            
1774 01607 0001 	.+0-W16Name
1775 01610 0013 	W16CFA-W15CFA
1776            W16CFA,
1777 01611 0000 	W16CFA-.		/ !
1778            W16PFA,
1779            / ! - Store
1780            / 
1781            / M: ( a b -> )
1782            / R: ( -> )
1783            / 
1784            / The longword a is stored at address b.
1785            / 
1786            / Revisions:
1787            / 07/29/99 RLI - code version
1788            / Fetch a
1789 01612 4460 	JMS I StupidLiteral0		/ 1
1790 01613 0001 	1
1791 01614 4450 	JMS I StupidFetchMP1		/ MP@
1792 01615 4505 	JMS I StupidSwap1		/ SWAP
1793 01616 4463 	JMS I StupidMinus1		/ -
1794 01617 4435 	JMS I StupidFetch0		/ @
1795            / Fetch b
1796 01620 4450 	JMS I StupidFetchMP1		/ MP@
1797 01621 4436 	JMS I StupidFetch1		/ @
1798            / Store the longword
1799 01622 4475 	JMS I StupidStore1		/ !
1800            / Drop a and b from the stack
1801 01623 4460 	JMS I StupidLiteral0		/ 1
1802 01624 0001 	1
1803 01625 4433 	JMS I StupidDup1			/ DUP
1804 01626 4471 	JMS I StupidPlus1			/ +
1805 01627 4450 	JMS I StupidFetchMP1		/ MP@
1806 01630 4505 	JMS I StupidSwap1		/ SWAP
1807 01631 4463 	JMS I StupidMinus1		/ -
1808 01632 4501 	JMS I StupidStoreMP0		/ MP!
1809 01633 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1810 01634 4503 	JMS I StupidStorePC0		/ PC!
1811            
1812            
1813            / ----	B! -- word # 17
1814            
1815            W17Name,
1816            
1817            	/ stringengize( B! )
1818 01635 0102 102
1819 01636 0041 41
1820            
1821 01637 0002 	.+0-W17Name
1822 01640 0030 	W17CFA-W16CFA
1823            W17CFA,
1824 01641 0000 	W17CFA-.		/ B!
1825            W17PFA,
1826            / B! - Byte store
1827            / 
1828            / M: ( a b -> )
1829            / R: ( -> )
1830            / 
1831            / The byte a is stored at address b.
1832            / 
1833            / Revisions:
1834            / 07/29/99 RLI - code version
1835            / Fetch the byte and the address at which it should be stored.
1836 01642 4460 	JMS I StupidLiteral0		/ 1
1837 01643 0001 	1
1838 01644 4450 	JMS I StupidFetchMP1		/ MP@
1839 01645 4505 	JMS I StupidSwap1		/ SWAP
1840 01646 4463 	JMS I StupidMinus1		/ -
1841 01647 4435 	JMS I StupidFetch0		/ @
1842 01650 4450 	JMS I StupidFetchMP1		/ MP@
1843 01651 4436 	JMS I StupidFetch1		/ @
1844            / Store the byte a at address b
1845            				/ !.b
1846 01652 4475 	JMS I StupidStore1		/ !
1847            / Drop a and b from the math stack
1848 01653 4460 	JMS I StupidLiteral0		/ 1
1849 01654 0001 	1
1850 01655 4433 	JMS I StupidDup1			/ DUP
1851 01656 4471 	JMS I StupidPlus1			/ +
1852 01657 4450 	JMS I StupidFetchMP1		/ MP@
1853 01660 4505 	JMS I StupidSwap1		/ SWAP
1854 01661 4463 	JMS I StupidMinus1		/ -
1855 01662 4501 	JMS I StupidStoreMP0		/ MP!
1856 01663 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1857 01664 4503 	JMS I StupidStorePC0		/ PC!
1858            
1859            
1860            / ----	W! -- word # 18
1861            
1862            W18Name,
1863            
1864            	/ stringengize( W! )
1865 01665 0127 127
1866 01666 0041 41
1867            
1868 01667 0002 	.+0-W18Name
1869 01670 0030 	W18CFA-W17CFA
1870            W18CFA,
1871 01671 0000 	W18CFA-.		/ W!
1872            W18PFA,
1873            / W! - Word store
1874            / 
1875            / M: ( a, b -> )
1876            / R: ( -> )
1877            / 
1878            / The word a is stored at address b.
1879            / 
1880            / Revisions:
1881            / 07/29/99 RLI - code version
1882            / Fetch a
1883 01672 4460 	JMS I StupidLiteral0		/ 1
1884 01673 0001 	1
1885 01674 4450 	JMS I StupidFetchMP1		/ MP@
1886 01675 4505 	JMS I StupidSwap1		/ SWAP
1887 01676 4463 	JMS I StupidMinus1		/ -
1888 01677 4435 	JMS I StupidFetch0		/ @
1889            / Fetch b
1890 01700 4450 	JMS I StupidFetchMP1		/ MP@
1891 01701 4436 	JMS I StupidFetch1		/ @
1892            / Store a at b
1893            					/ !.w -> !
1894 01702 4475 	JMS I StupidStore1		/ !
1895            / Drop a and b from the math stack
1896 01703 4460 	JMS I StupidLiteral0		/ 1
1897 01704 0001 	1
1898 01705 4433 	JMS I StupidDup1			/ DUP
1899 01706 4471 	JMS I StupidPlus1			/ +
1900 01707 4450 	JMS I StupidFetchMP1		/ MP@
1901 01710 4505 	JMS I StupidSwap1		/ SWAP
1902 01711 4463 	JMS I StupidMinus1		/ -
1903 01712 4501 	JMS I StupidStoreMP0		/ MP!
1904 01713 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1905 01714 4503 	JMS I StupidStorePC0		/ PC!
1906            / --	++ - Increments a variable
1907            / 
1908            / ( v -> )
1909            / 
1910            / The longword at v is fetched, incremented, and stored back.
1911            
1912            
1913            / ----	++ -- word # 19
1914            
1915            W19Name,
1916            
1917            	/ stringengize( ++ )
1918 01715 0053 53
1919 01716 0053 53
1920            
1921 01717 0002 	.+0-W19Name
1922 01720 0030 	W19CFA-W18CFA
1923            W19CFA,
1924 01721 7340 	W4CFA-.		/ (:)
1925            W19PFA,
1926 01722 0014 	W20CFA-.		/ DUP
1927 01723 7604 	W12CFA-.		/ @
1928 01724 0635 	W21CFA-.		/ 1
1929 01725 0317 	W22CFA-.		/ +
1930 01726 0032 	W23CFA-.		/ SWAP
1931 01727 7662 	W16CFA-.		/ !
1932 01730 7357 	W5CFA-.		/ (;)
1933            / ----
1934            / 
1935            / Stack manipulation
1936            / 
1937            / ----
1938            
1939            
1940            / ----	DUP -- word # 20
1941            
1942            W20Name,
1943            
1944            	/ stringengize( DUP )
1945 01731 0104 104
1946 01732 0125 125
1947 01733 0120 120
1948            
1949 01734 0003 	.+0-W20Name
1950 01735 0015 	W20CFA-W19CFA
1951            W20CFA,
1952 01736 0000 	W20CFA-.		/ DUP
1953            W20PFA,
1954            / DUP - Duplicate top of stack
1955            / 
1956            / M: ( a -> a, a )
1957            / R: ( -> )
1958            / 
1959            / Push a copy of whatever is on the top of the math stack onto the
1960            / math stack.
1961            / 
1962            / Revisions:
1963            / 07/29/96 RLI - Modified for new register usage.
1964            / 07/29/99 RLI - code version
1965            / Fetch a
1966 01737 4447 	JMS I StupidFetchMP0		/ MP@
1967 01740 4435 	JMS I StupidFetch0		/ @
1968            / Make space for the copy of a on the math stack
1969 01741 4461 	JMS I StupidLiteral1		/ 1
1970 01742 0001 	1
1971 01743 4451 	JMS I StupidFetchMP2		/ MP@
1972 01744 4472 	JMS I StupidPlus2			/ +
1973 01745 4502 	JMS I StupidStoreMP1		/ MP!
1974            / Store the new copy of a
1975 01746 4450 	JMS I StupidFetchMP1		/ MP@
1976 01747 4475 	JMS I StupidStore1		/ !
1977 01750 4453 	JMS I StupidFetchNEXT0		/ NEXT@
1978 01751 4503 	JMS I StupidStorePC0		/ PC!
1979            
1980            
1981            / ----	SWAP -- word # 23
1982            
1983            W23Name,
1984            
1985            	/ stringengize( SWAP )
1986 01752 0123 123
1987 01753 0127 127
1988 01754 0101 101
1989 01755 0120 120
1990            
1991 01756 0004 	.+0-W23Name
1992 01757 0022 	W23CFA-W20CFA
1993            W23CFA,
1994 01760 0000 	W23CFA-.		/ SWAP
1995            W23PFA,
1996            / SWAP - Swap the top two items on the stack
1997            / 
1998            / M: ( a, b -> b, a )
1999            / R: ( -> )
2000            / 
2001            / Revisions:
2002            / 07/29/99 RLI - code version
2003            / Fetch a and b
2004 01761 4460 	JMS I StupidLiteral0		/ 1
2005 01762 0001 	1
2006 01763 4450 	JMS I StupidFetchMP1		/ MP@
2007 01764 4505 	JMS I StupidSwap1		/ SWAP
2008 01765 4463 	JMS I StupidMinus1		/ -
2009 01766 4435 	JMS I StupidFetch0		/ @
2010 01767 4450 	JMS I StupidFetchMP1		/ MP@
2011 01770 4436 	JMS I StupidFetch1		/ @
2012            / Store b and a
2013 01771 4462 	JMS I StupidLiteral2		/ 1
2014 01772 0001 	1
2015 01773 4452 	JMS I StupidFetchMP3		/ MP@
2016 01774 4507 	JMS I StupidSwap3		/ SWAP
2017 01775 4465 	JMS I StupidMinus3		/ -
2018 01776 4476 	JMS I StupidStore2		/ !
2019 01777 4450 	JMS I StupidFetchMP1		/ MP@
2020 02000 4475 	JMS I StupidStore1		/ !
2021 02001 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2022 02002 4503 	JMS I StupidStorePC0		/ PC!
2023            
2024            
2025            / ----	DROP -- word # 24
2026            
2027            W24Name,
2028            
2029            	/ stringengize( DROP )
2030 02003 0104 104
2031 02004 0122 122
2032 02005 0117 117
2033 02006 0120 120
2034            
2035 02007 0004 	.+0-W24Name
2036 02010 0031 	W24CFA-W23CFA
2037            W24CFA,
2038 02011 0000 	W24CFA-.		/ DROP
2039            W24PFA,
2040            / DROP - Forget top of stack
2041            / 
2042            / M: ( a -> )
2043            / R: ( -> )
2044            / 
2045            / This could be done as : DROP DUP - - ; but that's just as long as
2046            / the machine code...
2047            / 
2048            / Revisions:
2049            / 07/29/99 RLI - code version
2050            / Drop a from the stack
2051 02012 4460 	JMS I StupidLiteral0		/ 1
2052 02013 0001 	1
2053 02014 4450 	JMS I StupidFetchMP1		/ MP@
2054 02015 4505 	JMS I StupidSwap1		/ SWAP
2055 02016 4463 	JMS I StupidMinus1		/ -
2056 02017 4501 	JMS I StupidStoreMP0		/ MP!
2057 02020 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2058 02021 4503 	JMS I StupidStorePC0		/ PC!
2059            
2060            
2061            / ----	>R -- word # 25
2062            
2063            W25Name,
2064            
2065            	/ stringengize( >R )
2066 02022 0076 76
2067 02023 0122 122
2068            
2069 02024 0002 	.+0-W25Name
2070 02025 0015 	W25CFA-W24CFA
2071            W25CFA,
2072 02026 0000 	W25CFA-.		/ >R
2073            W25PFA,
2074            / >R - Transfer an item from the math stack to the return stack
2075            / 
2076            / M:( a -> )
2077            / R: ( -> a )
2078            / 
2079            / Revisions:
2080            / 07/29/99 RLI - code version
2081            / Make space for an item on the return stack
2082 02027 4460 	JMS I StupidLiteral0		/ 1
2083 02030 0001 	1
2084 02031 4455 	JMS I StupidFetchRP1		/ RP@
2085 02032 4505 	JMS I StupidSwap1		/ SWAP
2086 02033 4463 	JMS I StupidMinus1		/ -
2087 02034 4504 	JMS I StupidStoreRP0		/ RP!
2088            / Copy a from the math stack to the return stack.
2089 02035 4447 	JMS I StupidFetchMP0		/ MP@
2090 02036 4435 	JMS I StupidFetch0		/ @
2091 02037 4455 	JMS I StupidFetchRP1		/ RP@
2092 02040 4475 	JMS I StupidStore1		/ !
2093            / Drop a from the math stack.
2094 02041 4460 	JMS I StupidLiteral0		/ 1
2095 02042 0001 	1
2096 02043 4450 	JMS I StupidFetchMP1		/ MP@
2097 02044 4505 	JMS I StupidSwap1		/ SWAP
2098 02045 4463 	JMS I StupidMinus1		/ -
2099 02046 4501 	JMS I StupidStoreMP0		/ MP!
2100 02047 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2101 02050 4503 	JMS I StupidStorePC0		/ PC!
2102            
2103            
2104            / ----	<R -- word # 26
2105            
2106            W26Name,
2107            
2108            	/ stringengize( <R )
2109 02051 0074 74
2110 02052 0122 122
2111            
2112 02053 0002 	.+0-W26Name
2113 02054 0027 	W26CFA-W25CFA
2114            W26CFA,
2115 02055 0000 	W26CFA-.		/ <R
2116            W26PFA,
2117            / <R - Transfer an item from the return stack to the math stack
2118            / 
2119            / M: ( -> a )
2120            / R: ( a -> )
2121            / 
2122            / Revisions:
2123            / 07/30/99 RLI - code version
2124            / Make space on the math stack for one cell.
2125 02056 4460 	JMS I StupidLiteral0		/ 1
2126 02057 0001 	1
2127 02060 4450 	JMS I StupidFetchMP1		/ MP@
2128 02061 4471 	JMS I StupidPlus1			/ +
2129 02062 4501 	JMS I StupidStoreMP0		/ MP!
2130            / Fetch the top of the return stack
2131 02063 4454 	JMS I StupidFetchRP0		/ RP@
2132 02064 4435 	JMS I StupidFetch0		/ @
2133            / Store it on the math stack
2134 02065 4450 	JMS I StupidFetchMP1		/ MP@
2135 02066 4475 	JMS I StupidStore1		/ !
2136            / Drop a from the return stack.
2137 02067 4460 	JMS I StupidLiteral0		/ 1
2138 02070 0001 	1
2139 02071 4455 	JMS I StupidFetchRP1		/ RP@
2140 02072 4471 	JMS I StupidPlus1			/ +
2141 02073 4504 	JMS I StupidStoreRP0		/ RP!
2142 02074 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2143 02075 4503 	JMS I StupidStorePC0		/ PC!
2144            
2145            
2146            / ----	R -- word # 27
2147            
2148            W27Name,
2149            
2150            	/ stringengize( R )
2151 02076 0122 122
2152            
2153 02077 0001 	.+0-W27Name
2154 02100 0024 	W27CFA-W26CFA
2155            W27CFA,
2156 02101 0000 	W27CFA-.		/ R
2157            W27PFA,
2158            / R - Transfer an item from the return stack to the math stack, but
2159            /     don't pop the math stack.
2160            / 
2161            / M: ( -> a )
2162            / R: ( a -> a )
2163            / 
2164            / Revisions:
2165            / 07/29/99 RLI - code version.
2166            / Make space on the math stack for one cell.
2167 02102 4460 	JMS I StupidLiteral0		/ 1
2168 02103 0001 	1
2169 02104 4450 	JMS I StupidFetchMP1		/ MP@
2170 02105 4471 	JMS I StupidPlus1			/ +
2171 02106 4501 	JMS I StupidStoreMP0		/ MP!
2172            / Copy the top of the return stack over to the math stack.
2173 02107 4454 	JMS I StupidFetchRP0		/ RP@
2174 02110 4435 	JMS I StupidFetch0		/ @
2175 02111 4450 	JMS I StupidFetchMP1		/ MP@
2176 02112 4475 	JMS I StupidStore1		/ !
2177 02113 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2178 02114 4503 	JMS I StupidStorePC0		/ PC!
2179            
2180            
2181            / ----	RP! -- word # 28
2182            
2183            W28Name,
2184            
2185            	/ stringengize( RP! )
2186 02115 0122 122
2187 02116 0120 120
2188 02117 0041 41
2189            
2190 02120 0003 	.+0-W28Name
2191 02121 0021 	W28CFA-W27CFA
2192            W28CFA,
2193 02122 0000 	W28CFA-.		/ RP!
2194            W28PFA,
2195            / RP! - Initialize the return pointer
2196            / 
2197            / M: ( -> )
2198            / R: Initialized
2199            / 
2200            / This is used during error recovery and system initialization. When
2201            / aborting from an error, the return stack is cleaned and we go back
2202            / to interpreting.
2203            / 
2204            / Revisions:
2205            / 07/29/99 RLI - code version.
2206 02123 4446 	JMS I StupidFetchInitialRP0		/ InitialRP@
2207 02124 4504 	JMS I StupidStoreRP0		/ RP!
2208 02125 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2209 02126 4503 	JMS I StupidStorePC0		/ PC!
2210            / --	OVER - Duplicate second item on math stack
2211            / 
2212            / ( a b -> a b a )
2213            / 
2214            / This is smaller than the equivalent assembly on an i960
2215            
2216            
2217            / ----	OVER -- word # 29
2218            
2219            W29Name,
2220            
2221            	/ stringengize( OVER )
2222 02127 0117 117
2223 02130 0126 126
2224 02131 0105 105
2225 02132 0122 122
2226            
2227 02133 0004 	.+0-W29Name
2228 02134 0013 	W29CFA-W28CFA
2229            W29CFA,
2230 02135 7124 	W4CFA-.		/ (:)
2231            W29PFA,
2232 02136 7670 	W25CFA-.		/ >R
2233 02137 7577 	W20CFA-.		/ DUP
2234 02140 7715 	W26CFA-.		/ <R
2235 02141 7617 	W23CFA-.		/ SWAP
2236 02142 7145 	W5CFA-.		/ (;)
2237            
2238            
2239            / ----	MP! -- word # 30
2240            
2241            W30Name,
2242            
2243            	/ stringengize( MP! )
2244 02143 0115 115
2245 02144 0120 120
2246 02145 0041 41
2247            
2248 02146 0003 	.+0-W30Name
2249 02147 0013 	W30CFA-W29CFA
2250            W30CFA,
2251 02150 0000 	W30CFA-.		/ MP!
2252            W30PFA,
2253            / MP! - Initialize the math stack pointer
2254            / 
2255            / M: Initialized
2256            / R: ( -> )
2257            / 
2258            / This is used during error recovery and system initialization. When
2259            / aborting from an error, the math  stack is cleaned and we go back
2260            / to interpreting.
2261            / 
2262            / Revisions:
2263            / 07/29/99 RLI - code version
2264            / Initialize MP
2265 02151 4445 	JMS I StupidFetchInitialMP0		/ InitialMP@
2266 02152 4501 	JMS I StupidStoreMP0		/ MP!
2267 02153 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2268 02154 4503 	JMS I StupidStorePC0		/ PC!
2269            
2270            
2271            / ----	MP@ -- word # 31
2272            
2273            W31Name,
2274            
2275            	/ stringengize( MP@ )
2276 02155 0115 115
2277 02156 0120 120
2278 02157 0100 100
2279            
2280 02160 0003 	.+0-W31Name
2281 02161 0012 	W31CFA-W30CFA
2282            W31CFA,
2283 02162 0000 	W31CFA-.		/ MP@
2284            W31PFA,
2285            / MP@ - Fetch the math stack pointer
2286            / 
2287            / M: ( -> MP )
2288            / R: ( -> )
2289            / 
2290            / This is used by the compiler to verify that the stack has been cleaned
2291            / off at the end of compilation. If the math stack at the start of
2292            / compilation and the math stack at the end of compilation don't match,
2293            / there is probably an unclosed control loop.
2294            / 
2295            / It should not be assumed that the value returned by MP@ can be used
2296            / as an address from which the top item of the math stack can be
2297            / fetched; different implementations will have different levels of
2298            / stack caching and even differing points in MP@ where the pointer
2299            / is updated to make room for a copy of itself.
2300            / 
2301            / Revisions:
2302            / 07/29/99 RLI - code version
2303            / Make space on the math stack for one cell.
2304 02163 4460 	JMS I StupidLiteral0		/ 1
2305 02164 0001 	1
2306 02165 4450 	JMS I StupidFetchMP1		/ MP@
2307 02166 4471 	JMS I StupidPlus1			/ +
2308 02167 4501 	JMS I StupidStoreMP0		/ MP!
2309            / Store a copy of the MP on the math stack.
2310 02170 4447 	JMS I StupidFetchMP0		/ MP@
2311 02171 4450 	JMS I StupidFetchMP1		/ MP@
2312 02172 4475 	JMS I StupidStore1		/ !
2313 02173 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2314 02174 4503 	JMS I StupidStorePC0		/ PC!
2315            / ----
2316            / 
2317            / Arithmetic and Logic
2318            / 
2319            / These words perform arithmetic and logic on 32-bit integers.
2320            / 
2321            / ----
2322            
2323            
2324            / ----	- -- word # 32
2325            
2326            W32Name,
2327            
2328            	/ stringengize( - )
2329 02175 0055 55
2330            
2331 02176 0001 	.+0-W32Name
2332 02177 0016 	W32CFA-W31CFA
2333            W32CFA,
2334 02200 0000 	W32CFA-.		/ -
2335            W32PFA,
2336            / - - Integer subtraction
2337            / 
2338            / M: ( a, b -> a-b )
2339            / R: ( -> )
2340            / 
2341            / This word does integer subtraction.
2342            / 
2343            / Revision:
2344            / 07/29/99 RLI - code version
2345            / Fetch a
2346 02201 4460 	JMS I StupidLiteral0		/ 1
2347 02202 0001 	1
2348 02203 4450 	JMS I StupidFetchMP1		/ MP@
2349 02204 4505 	JMS I StupidSwap1		/ SWAP
2350 02205 4463 	JMS I StupidMinus1		/ -
2351 02206 4435 	JMS I StupidFetch0		/ @
2352            / Fetch b
2353 02207 4450 	JMS I StupidFetchMP1		/ MP@
2354 02210 4436 	JMS I StupidFetch1		/ @
2355            / Form the difference
2356 02211 4463 	JMS I StupidMinus1		/ -
2357            / Drop b from the math stack
2358 02212 4461 	JMS I StupidLiteral1		/ 1
2359 02213 0001 	1
2360 02214 4451 	JMS I StupidFetchMP2		/ MP@
2361 02215 4506 	JMS I StupidSwap2		/ SWAP
2362 02216 4464 	JMS I StupidMinus2		/ -
2363 02217 4502 	JMS I StupidStoreMP1		/ MP!
2364            / Replace a with the difference
2365 02220 4450 	JMS I StupidFetchMP1		/ MP@
2366 02221 4475 	JMS I StupidStore1		/ !
2367 02222 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2368 02223 4503 	JMS I StupidStorePC0		/ PC!
2369            
2370            
2371            / ----	NEG -- word # 33
2372            
2373            W33Name,
2374            
2375            	/ stringengize( NEG )
2376 02224 0116 116
2377 02225 0105 105
2378 02226 0107 107
2379            
2380 02227 0003 	.+0-W33Name
2381 02230 0031 	W33CFA-W32CFA
2382            W33CFA,
2383 02231 0000 	W33CFA-.		/ NEG
2384            W33PFA,
2385            / NEG - Form 2's complement of the top of the math stack.
2386            / 
2387            / M: ( a -> -a )
2388            / R: ( -> )
2389            / 
2390            / Revision:
2391            / 07/29/99 RLI - code version
2392 02232 4447 	JMS I StupidFetchMP0		/ MP@
2393 02233 4435 	JMS I StupidFetch0		/ @
2394 02234 4466 	JMS I StupidNeg0			/ NEG
2395 02235 4450 	JMS I StupidFetchMP1		/ MP@
2396 02236 4475 	JMS I StupidStore1		/ !
2397 02237 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2398 02240 4503 	JMS I StupidStorePC0		/ PC!
2399            
2400            
2401            / ----	+ -- word # 22
2402            
2403            W22Name,
2404            
2405            	/ stringengize( + )
2406 02241 0053 53
2407            
2408 02242 0001 	.+0-W22Name
2409 02243 0013 	W22CFA-W33CFA
2410            W22CFA,
2411 02244 0000 	W22CFA-.		/ +
2412            W22PFA,
2413            / + - Integer addition
2414            / 
2415            / M: ( a, b -> a+b )
2416            / R: ( -> )
2417            / 
2418            / This word does integer addition.
2419            / 
2420            / Revision:
2421            / 07/29/99 RLI - code version
2422            / Fetch a
2423 02245 4460 	JMS I StupidLiteral0		/ 1
2424 02246 0001 	1
2425 02247 4450 	JMS I StupidFetchMP1		/ MP@
2426 02250 4505 	JMS I StupidSwap1		/ SWAP
2427 02251 4463 	JMS I StupidMinus1		/ -
2428 02252 4435 	JMS I StupidFetch0		/ @
2429            / Fetch b
2430 02253 4450 	JMS I StupidFetchMP1		/ MP@
2431 02254 4436 	JMS I StupidFetch1		/ @
2432            / Form the sum
2433 02255 4471 	JMS I StupidPlus1			/ +
2434            / Drop b from the math stack
2435 02256 4461 	JMS I StupidLiteral1		/ 1
2436 02257 0001 	1
2437 02260 4451 	JMS I StupidFetchMP2		/ MP@
2438 02261 4506 	JMS I StupidSwap2		/ SWAP
2439 02262 4464 	JMS I StupidMinus2		/ -
2440 02263 4502 	JMS I StupidStoreMP1		/ MP!
2441            / Replace a with the sum
2442 02264 4450 	JMS I StupidFetchMP1		/ MP@
2443 02265 4475 	JMS I StupidStore1		/ !
2444 02266 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2445 02267 4503 	JMS I StupidStorePC0		/ PC!
2446            
2447            
2448            / ----	AND -- word # 34
2449            
2450            W34Name,
2451            
2452            	/ stringengize( AND )
2453 02270 0101 101
2454 02271 0116 116
2455 02272 0104 104
2456            
2457 02273 0003 	.+0-W34Name
2458 02274 0031 	W34CFA-W22CFA
2459            W34CFA,
2460 02275 0000 	W34CFA-.		/ AND
2461            W34PFA,
2462            / AND - Bitwise logical AND
2463            / 
2464            / M: ( a, b -> a&b )
2465            / R: ( -> )
2466            / 
2467            / Revisions:
2468            / 
2469            / 07/29/99 RLI - code version.
2470            / Fetch a and b.
2471 02276 4447 	JMS I StupidFetchMP0		/ MP@
2472 02277 4435 	JMS I StupidFetch0		/ @
2473 02300 4461 	JMS I StupidLiteral1		/ 1
2474 02301 0001 	1
2475 02302 4451 	JMS I StupidFetchMP2		/ MP@
2476 02303 4506 	JMS I StupidSwap2		/ SWAP
2477 02304 4464 	JMS I StupidMinus2		/ -
2478 02305 4436 	JMS I StupidFetch1		/ @
2479            / Form the result
2480 02306 4432 	JMS I StupidAnd1			/ AND
2481            / Drop a from the math stack
2482 02307 4461 	JMS I StupidLiteral1		/ 1
2483 02310 0001 	1
2484 02311 4451 	JMS I StupidFetchMP2		/ MP@
2485 02312 4506 	JMS I StupidSwap2		/ SWAP
2486 02313 4464 	JMS I StupidMinus2		/ -
2487 02314 4502 	JMS I StupidStoreMP1		/ MP!
2488            / Replace b with the result
2489 02315 4450 	JMS I StupidFetchMP1		/ MP@
2490 02316 4475 	JMS I StupidStore1		/ !
2491            / Execute the next FORTH word
2492 02317 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2493 02320 4503 	JMS I StupidStorePC0		/ PC!
2494            
2495            
2496            / ----	OR -- word # 35
2497            
2498            W35Name,
2499            
2500            	/ stringengize( OR )
2501 02321 0117 117
2502 02322 0122 122
2503            
2504 02323 0002 	.+0-W35Name
2505 02324 0030 	W35CFA-W34CFA
2506            W35CFA,
2507 02325 0000 	W35CFA-.		/ OR
2508            W35PFA,
2509            / OR - Bitwise logical OR
2510            / 
2511            / M: ( a, b -> a or b )
2512            / R: ( -> )
2513            / 
2514            / Revisions:
2515            / 07/29/99 RLI - code version
2516            / Fetch a
2517 02326 4460 	JMS I StupidLiteral0		/ 1
2518 02327 0001 	1
2519 02330 4450 	JMS I StupidFetchMP1		/ MP@
2520 02331 4505 	JMS I StupidSwap1		/ SWAP
2521 02332 4463 	JMS I StupidMinus1		/ -
2522 02333 4435 	JMS I StupidFetch0		/ @
2523            / Fetch b
2524 02334 4450 	JMS I StupidFetchMP1		/ MP@
2525 02335 4436 	JMS I StupidFetch1		/ @
2526            / Form the result
2527 02336 4470 	JMS I StupidOr1			/ OR
2528            / Drop b from the math stack
2529 02337 4461 	JMS I StupidLiteral1		/ 1
2530 02340 0001 	1
2531 02341 4451 	JMS I StupidFetchMP2		/ MP@
2532 02342 4506 	JMS I StupidSwap2		/ SWAP
2533 02343 4464 	JMS I StupidMinus2		/ -
2534 02344 4502 	JMS I StupidStoreMP1		/ MP!
2535            / Replace a with the result
2536 02345 4450 	JMS I StupidFetchMP1		/ MP@
2537 02346 4475 	JMS I StupidStore1		/ !
2538 02347 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2539 02350 4503 	JMS I StupidStorePC0		/ PC!
2540            
2541            
2542            / ----	NOT -- word # 36
2543            
2544            W36Name,
2545            
2546            	/ stringengize( NOT )
2547 02351 0116 116
2548 02352 0117 117
2549 02353 0124 124
2550            
2551 02354 0003 	.+0-W36Name
2552 02355 0031 	W36CFA-W35CFA
2553            W36CFA,
2554 02356 0000 	W36CFA-.		/ NOT
2555            W36PFA,
2556            / NOT - Form 1's complement of the top of the math stack.
2557            / 
2558            / M: ( a -> ~a )
2559            / R: ( -> )
2560            / 
2561            / Revision:
2562            / 07/29/99 RLI - code version
2563 02357 4447 	JMS I StupidFetchMP0		/ MP@
2564 02360 4435 	JMS I StupidFetch0		/ @
2565 02361 4467 	JMS I StupidNot0			/ NOT
2566 02362 4450 	JMS I StupidFetchMP1		/ MP@
2567 02363 4475 	JMS I StupidStore1		/ !
2568 02364 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2569 02365 4503 	JMS I StupidStorePC0		/ PC!
2570            
2571            
2572            / ----	<< -- word # 37
2573            
2574            W37Name,
2575            
2576            	/ stringengize( << )
2577 02366 0074 74
2578 02367 0074 74
2579            
2580 02370 0002 	.+0-W37Name
2581 02371 0014 	W37CFA-W36CFA
2582            W37CFA,
2583 02372 0000 	W37CFA-.		/ <<
2584            W37PFA,
2585            / << - Logical left shift
2586            / 
2587            / M: ( a, b -> a<<b )
2588            / 
2589            / Revisions:
2590            / 07/29/99 RLI - code version
2591            / Fetch a
2592 02373 4460 	JMS I StupidLiteral0		/ 1
2593 02374 0001 	1
2594 02375 4450 	JMS I StupidFetchMP1		/ MP@
2595 02376 4505 	JMS I StupidSwap1		/ SWAP
2596 02377 4463 	JMS I StupidMinus1		/ -
2597 02400 4435 	JMS I StupidFetch0		/ @
2598            / Fetch b
2599 02401 4450 	JMS I StupidFetchMP1		/ MP@
2600 02402 4436 	JMS I StupidFetch1		/ @
2601            / Form the result
2602 02403 4473 	JMS I StupidShiftLeft1		/ <<
2603            / Drop b from the math stack
2604 02404 4461 	JMS I StupidLiteral1		/ 1
2605 02405 0001 	1
2606 02406 4451 	JMS I StupidFetchMP2		/ MP@
2607 02407 4506 	JMS I StupidSwap2		/ SWAP
2608 02410 4464 	JMS I StupidMinus2		/ -
2609 02411 4502 	JMS I StupidStoreMP1		/ MP!
2610            / Replace a with the result
2611 02412 4450 	JMS I StupidFetchMP1		/ MP@
2612 02413 4475 	JMS I StupidStore1		/ !
2613 02414 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2614 02415 4503 	JMS I StupidStorePC0		/ PC!
2615            
2616            
2617            / ----	>> -- word # 38
2618            
2619            W38Name,
2620            
2621            	/ stringengize( >> )
2622 02416 0076 76
2623 02417 0076 76
2624            
2625 02420 0002 	.+0-W38Name
2626 02421 0030 	W38CFA-W37CFA
2627            W38CFA,
2628 02422 0000 	W38CFA-.		/ >>
2629            W38PFA,
2630            / >> - Logical right shift
2631            / 
2632            / M: ( a, b -> a>>b )
2633            / R: ( -> )
2634            / 
2635            / Revisions:
2636            / 07/29/99 RLI - code version
2637            / Fetch a
2638 02423 4460 	JMS I StupidLiteral0		/ 1
2639 02424 0001 	1
2640 02425 4450 	JMS I StupidFetchMP1		/ MP@
2641 02426 4505 	JMS I StupidSwap1		/ SWAP
2642 02427 4463 	JMS I StupidMinus1		/ -
2643 02430 4435 	JMS I StupidFetch0		/ @
2644            / Fetch b
2645 02431 4450 	JMS I StupidFetchMP1		/ MP@
2646 02432 4436 	JMS I StupidFetch1		/ @
2647            / Form result
2648 02433 4474 	JMS I StupidShiftRight1		/ >>
2649             / Drop b from the stack
2650 02434 4461 	JMS I StupidLiteral1		/ 1
2651 02435 0001 	1
2652 02436 4451 	JMS I StupidFetchMP2		/ MP@
2653 02437 4506 	JMS I StupidSwap2		/ SWAP
2654 02440 4464 	JMS I StupidMinus2		/ -
2655 02441 4502 	JMS I StupidStoreMP1		/ MP!
2656            / Replace a with the result
2657 02442 4450 	JMS I StupidFetchMP1		/ MP@
2658 02443 4475 	JMS I StupidStore1		/ !
2659 02444 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2660 02445 4503 	JMS I StupidStorePC0		/ PC!
2661            / ----
2662            / 
2663            / Comparisons
2664            / 
2665            / ----
2666            / --	0< - Integer comparison to zero
2667            / 
2668            / ( a -> 1 iff a<0 )
2669            / ( a -> 0 otherwise )
2670            / 
2671            / This implementation works by moving the sign bit to bit 0. It
2672            / assumes >> is a logical shift.
2673            
2674            
2675            / ----	0< -- word # 39
2676            
2677            W39Name,
2678            
2679            	/ stringengize( 0< )
2680 02446 0060 60
2681 02447 0074 74
2682            
2683 02450 0002 	.+0-W39Name
2684 02451 0030 	W39CFA-W38CFA
2685            W39CFA,
2686 02452 6607 	W4CFA-.		/ (:)
2687            W39PFA,
2688 02453 0055 	W40CFA-.		/ (LIT)
2689 02454 0013 	13		/ 11
2690 02455 7745 	W38CFA-.		/ >>
2691 02456 6631 	W5CFA-.		/ (;)
2692            / --	< - Integer less-than comparison
2693            / 
2694            / ( a b -> 1 iff a<b )
2695            / ( a b -> 0 otherwise )
2696            / 
2697            / This implementation works by changing the problem to 0< which
2698            / is implemented above.
2699            
2700            
2701            / ----	< -- word # 41
2702            
2703            W41Name,
2704            
2705            	/ stringengize( < )
2706 02457 0074 74
2707            
2708 02460 0001 	.+0-W41Name
2709 02461 0010 	W41CFA-W39CFA
2710            W41CFA,
2711 02462 6577 	W4CFA-.		/ (:)
2712            W41PFA,
2713 02463 7515 	W32CFA-.		/ -
2714 02464 7766 	W39CFA-.		/ 0<
2715 02465 6622 	W5CFA-.		/ (;)
2716            / --	> - Integer greater-than comparison
2717            / 
2718            / ( a b -> 1 iff a>b )
2719            / ( a b -> 0 otherwise )
2720            / 
2721            / This implementation works by changing the problem to 0< which is
2722            / implemented above.
2723            
2724            
2725            / ----	> -- word # 42
2726            
2727            W42Name,
2728            
2729            	/ stringengize( > )
2730 02466 0076 76
2731            
2732 02467 0001 	.+0-W42Name
2733 02470 0007 	W42CFA-W41CFA
2734            W42CFA,
2735 02471 6570 	W4CFA-.		/ (:)
2736            W42PFA,
2737 02472 7506 	W32CFA-.		/ -
2738            / 	Possible results:
2739            / 	  a-b<0 iff b>a, or a<b
2740            / 	  a-b=0 iff b=a, or a=b
2741            / 	  a-b>0 iff b<a, or a>b
2742 02473 7536 	W33CFA-.		/ NEG
2743            / 	Possible results:
2744            / 	  -(a-b)>0 iff b>a, or a<b
2745            / 	  -(a-b)=0 iff b=a, or a=b
2746            / 	  -(a-b)<0 iff b<a, or a>b
2747 02474 7756 	W39CFA-.		/ 0<
2748 02475 6612 	W5CFA-.		/ (;)
2749            / --	0= - Integer comparison to zero
2750            / 
2751            / ( a -> 1 iff a=0 )
2752            / ( a -> 0 otherwise )
2753            / 
2754            / Note that this serves as a logical NOT.
2755            / 
2756            / Revisions:	06/25/96 RLI - Oops, didn't work. Made it simpler.
2757            / 		08/26/96 RLI - Oops. Did it backwards. Sigh.
2758            / 
2759            / : 0= if 1 else 0 endif ;
2760            
2761            
2762            / ----	0= -- word # 43
2763            
2764            W43Name,
2765            
2766            	/ stringengize( 0= )
2767 02476 0060 60
2768 02477 0075 75
2769            
2770 02500 0002 	.+0-W43Name
2771 02501 0011 	W43CFA-W42CFA
2772            W43CFA,
2773 02502 6557 	W4CFA-.		/ (:)
2774            W43PFA,
2775 02503 6734 	W10CFA-.		/ (0BRANCH)
2776 02504 0004 	W430-.
2777 02505 0047 	W44CFA-.		/ 0
2778 02506 6706 	W8CFA-.		/ (BRANCH)
2779 02507 0002 	W431-.
2780            W430,
2781 02510 0051 	W21CFA-.		/ 1
2782            W431,
2783 02511 6576 	W5CFA-.		/ (;)
2784            / --	= - Integer equals comparison
2785            / 
2786            / ( a b -> 1 iff a=b )
2787            / ( a b -> 0 otherwise )
2788            / 
2789            / This implementation works by changing the problem to 0= which is
2790            / defined above.
2791            
2792            
2793            / ----	= -- word # 45
2794            
2795            W45Name,
2796            
2797            	/ stringengize( = )
2798 02512 0075 75
2799            
2800 02513 0001 	.+0-W45Name
2801 02514 0013 	W45CFA-W43CFA
2802            W45CFA,
2803 02515 6544 	W4CFA-.		/ (:)
2804            W45PFA,
2805 02516 7462 	W32CFA-.		/ -
2806 02517 7763 	W43CFA-.		/ 0=
2807 02520 6567 	W5CFA-.		/ (;)
2808            / ----
2809            / 
2810            / Literals in the code
2811            / 
2812            / ----
2813            
2814            
2815            / ----	(LIT) -- word # 40
2816            
2817            W40Name,
2818            
2819            	/ stringengize( (LIT) )
2820 02521 0050 50
2821 02522 0114 114
2822 02523 0111 111
2823 02524 0124 124
2824 02525 0051 51
2825            
2826 02526 0005 	.+0-W40Name
2827 02527 0013 	W40CFA-W45CFA
2828            W40CFA,
2829 02530 0000 	W40CFA-.		/ (LIT)
2830            W40PFA,
2831            / (LIT) - Push a literal on the math stack
2832            / 
2833            / M: ( -> literal )
2834            / R: ( -> )
2835            / 
2836            / This word knows how to push a literal onto the math stack. The 
2837            / reference to (LIT) is followed by a cell containing the literal
2838            / to be pushed; that cell  is fetched and pushed on the stack.
2839            / 
2840            / Revisions:
2841            / 07/29/99 RLI - code version
2842            / Make space for the literal on the math stack.
2843 02531 4460 	JMS I StupidLiteral0		/ 1
2844 02532 0001 	1
2845 02533 4450 	JMS I StupidFetchMP1		/ MP@
2846 02534 4471 	JMS I StupidPlus1			/ +
2847 02535 4501 	JMS I StupidStoreMP0		/ MP!
2848            / Fetch the literal and store it on the math stack.
2849 02536 4441 	JMS I StupidFetchIP0		/ IP@
2850 02537 4435 	JMS I StupidFetch0		/ @
2851 02540 4450 	JMS I StupidFetchMP1		/ MP@
2852 02541 4475 	JMS I StupidStore1		/ !
2853            / Bump IP past the literal and continue on.
2854 02542 4441 	JMS I StupidFetchIP0		/ IP@
2855 02543 4461 	JMS I StupidLiteral1		/ 1
2856 02544 0001 	1
2857 02545 4471 	JMS I StupidPlus1			/ +
2858 02546 4500 	JMS I StupidStoreIP0		/ IP!
2859 02547 4453 	JMS I StupidFetchNEXT0		/ NEXT@
2860 02550 4503 	JMS I StupidStorePC0		/ PC!
2861            / ----
2862            / 
2863            / Frequently used constants
2864            / 
2865            / ----
2866            
2867            
2868            / ----	0 -- word # 44
2869            
2870            W44Name,
2871            
2872            	/ stringengize( 0 )
2873 02551 0060 60
2874            
2875 02552 0001 	.+0-W44Name
2876 02553 0024 	W44CFA-W40CFA
2877            W44CFA,
2878 02554 6562 	W6CFA-.		/ (CONSTANT)
2879            W44PFA,
2880 02555 0000 	0
2881            
2882            
2883            / ----	1 -- word # 21
2884            
2885            W21Name,
2886            
2887            	/ stringengize( 1 )
2888 02556 0061 61
2889            
2890 02557 0001 	.+0-W21Name
2891 02560 0005 	W21CFA-W44CFA
2892            W21CFA,
2893 02561 6555 	W6CFA-.		/ (CONSTANT)
2894            W21PFA,
2895 02562 0001 	1
2896            / ----
2897            / 
2898            / Higher level output
2899            / 
2900            / ----
2901            / --	.NYBBLE - Display high-order nybble of top of stack as ASCII hex
2902            / 
2903            / ( a -> a )
2904            / 
2905            / Revisions:	06/28/96 RLI - Removed assumption about word size.
2906            / 		Well, it stell better be less than 256+4 bits.
2907            / 			05/11/01 RLI - Tossed the "65-58" constant, because
2908            / 			there was no elegant way to deal with it in a
2909            / 			stupid conversion to PAL8.
2910            
2911            
2912            / ----	.NYBBLE -- word # 46
2913            
2914            W46Name,
2915            
2916            	/ stringengize( .NYBBLE )
2917 02563 0056 56
2918 02564 0116 116
2919 02565 0131 131
2920 02566 0102 102
2921 02567 0102 102
2922 02570 0114 114
2923 02571 0105 105
2924            
2925 02572 0007 	.+0-W46Name
2926 02573 0013 	W46CFA-W21CFA
2927            W46CFA,
2928 02574 6465 	W4CFA-.		/ (:)
2929            W46PFA,
2930 02575 7141 	W20CFA-.		/ DUP
2931 02576 7732 	W40CFA-.		/ (LIT)
2932 02577 0010 	10		/ 8
2933 02600 7622 	W38CFA-.		/ >>
2934 02601 7727 	W40CFA-.		/ (LIT)
2935 02602 0060 	60		/ 48
2936 02603 7441 	W22CFA-.		/ +
2937 02604 7132 	W20CFA-.		/ DUP
2938 02605 7723 	W40CFA-.		/ (LIT)
2939 02606 0071 	71		/ 57
2940 02607 7662 	W42CFA-.		/ >
2941 02610 6627 	W10CFA-.		/ (0BRANCH)
2942 02611 0007 	W460-.
2943 02612 7716 	W40CFA-.		/ (LIT)
2944 02613 0101 	101		/ 65
2945 02614 7714 	W40CFA-.		/ (LIT)
2946 02615 0072 	72		/ 58
2947 02616 7362 	W32CFA-.		/ -
2948 02617 7425 	W22CFA-.		/ +
2949            W460,
2950 02620 3357 	W47CFA-.		/ EMIT
2951 02621 6466 	W5CFA-.		/ (;)
2952            / --	.NYBBLES - Display a specified number of nybbles of the top of stack
2953            / 	in hex.
2954            / 
2955            / ( a b -> )
2956            
2957            
2958            / ----	.NYBBLES -- word # 48
2959            
2960            W48Name,
2961            
2962            	/ stringengize( .NYBBLES )
2963 02622 0056 56
2964 02623 0116 116
2965 02624 0131 131
2966 02625 0102 102
2967 02626 0102 102
2968 02627 0114 114
2969 02630 0105 105
2970 02631 0123 123
2971            
2972 02632 0010 	.+0-W48Name
2973 02633 0040 	W48CFA-W46CFA
2974            W48CFA,
2975 02634 6425 	W4CFA-.		/ (:)
2976            W48PFA,
2977            / We need to move the high-order nybble of the value we're going to
2978            / display to the high-order nybble of the longword we're going to
2979            / display. To do that, we need to dork with b; since we need a copy
2980            / later, we'll have to save it on the return stack.
2981 02635 7101 	W20CFA-.		/ DUP
2982 02636 7170 	W25CFA-.		/ >R
2983            / Now we need to calculate how many nybbles we need to shift the value
2984            / to the left so that the high-order bit of the first nybble we need
2985            / to display is at the high-order bit of the top of the math stack.
2986 02637 7671 	W40CFA-.		/ (LIT)
2987 02640 0003 	3		/ 3
2988 02641 7117 	W23CFA-.		/ SWAP
2989 02642 7336 	W32CFA-.		/ -
2990 02643 7665 	W40CFA-.		/ (LIT)
2991 02644 0002 	2		/ 2
2992 02645 7525 	W37CFA-.		/ <<
2993 02646 7524 	W37CFA-.		/ <<
2994            / Now we need to display b nybbles.
2995 02647 7206 	W26CFA-.		/ <R
2996 02650 7704 	W44CFA-.		/ 0
2997 02651 1566 	W49CFA-.		/ (DO)
2998            W480,
2999 02652 7722 	W46CFA-.		/ .NYBBLE
3000 02653 7655 	W40CFA-.		/ (LIT)
3001 02654 0004 	4		/ 4
3002 02655 7515 	W37CFA-.		/ <<
3003 02656 1436 	W50CFA-.		/ (LOOP)
3004 02657 7773 	W480-.
3005            / We've now displayed the value, but we have a zero left on top of the
3006            / stack. Drop it and exit.
3007 02660 7131 	W24CFA-.		/ DROP
3008 02661 6426 	W5CFA-.		/ (;)
3009            / --	. - Display all of the nybbles in the top of stack in hex.
3010            / 
3011            / ( a -> )
3012            / 
3013            / Revisions:	06/26/96 RLI - Added a space after the number
3014            / 		06/28/96 RLI - Removed assumption about word size
3015            
3016            
3017            / ----	. -- word # 51
3018            
3019            W51Name,
3020            
3021            	/ stringengize( . )
3022 02662 0056 56
3023            
3024 02663 0001 	.+0-W51Name
3025 02664 0031 	W51CFA-W48CFA
3026            W51CFA,
3027 02665 6374 	W4CFA-.		/ (:)
3028            W51PFA,
3029 02666 7642 	W40CFA-.		/ (LIT)
3030 02667 0003 	3		/ 3
3031 02670 7744 	W48CFA-.		/ .NYBBLES
3032 02671 7637 	W40CFA-.		/ (LIT)
3033 02672 0040 	40		/ 32
3034 02673 3304 	W47CFA-.		/ EMIT
3035 02674 6413 	W5CFA-.		/ (;)
3036            / --	TYPE - Display a counted string
3037            / 
3038            / ( a c -> )
3039            / 
3040            / c characters are displayed from memory starting at address a.
3041            
3042            
3043            / ----	TYPE -- word # 52
3044            
3045            W52Name,
3046            
3047            	/ stringengize( TYPE )
3048 02675 0124 124
3049 02676 0131 131
3050 02677 0120 120
3051 02700 0105 105
3052            
3053 02701 0004 	.+0-W52Name
3054 02702 0016 	W52CFA-W51CFA
3055            W52CFA,
3056 02703 6356 	W4CFA-.		/ (:)
3057            W52PFA,
3058 02704 7624 	W40CFA-.		/ (LIT)
3059 02705 0000 	0		/ 0
3060 02706 1531 	W49CFA-.		/ (DO)
3061            W520,
3062 02707 7027 	W20CFA-.		/ DUP
3063 02710 6633 	W13CFA-.		/ B@
3064 02711 3266 	W47CFA-.		/ EMIT
3065 02712 7616 	W40CFA-.		/ (LIT)
3066 02713 0001 	1		/ 1
3067 02714 7330 	W22CFA-.		/ +
3068 02715 1377 	W50CFA-.		/ (LOOP)
3069 02716 7771 	W520-.
3070 02717 7072 	W24CFA-.		/ DROP
3071 02720 6367 	W5CFA-.		/ (;)
3072            / --	COUNT - Extract info about a conted string in memory
3073            / 
3074            / ( a -> a+1 c )
3075            / 
3076            / Given the address of a counted string in memory, returns the
3077            / address of the start of the string and the length of the string
3078            / on the stack.
3079            
3080            
3081            / ----	COUNT -- word # 53
3082            
3083            W53Name,
3084            
3085            	/ stringengize( COUNT )
3086 02721 0103 103
3087 02722 0117 117
3088 02723 0125 125
3089 02724 0116 116
3090 02725 0124 124
3091            
3092 02726 0005 	.+0-W53Name
3093 02727 0025 	W53CFA-W52CFA
3094            W53CFA,
3095 02730 6331 	W4CFA-.		/ (:)
3096            W53PFA,
3097 02731 7005 	W20CFA-.		/ DUP
3098 02732 6611 	W13CFA-.		/ B@
3099 02733 7025 	W23CFA-.		/ SWAP
3100 02734 7625 	W21CFA-.		/ 1
3101 02735 7307 	W22CFA-.		/ +
3102 02736 7022 	W23CFA-.		/ SWAP
3103 02737 6350 	W5CFA-.		/ (;)
3104            / ----
3105            / 
3106            /     Higher level input
3107            / 
3108            / These words are concerned with accepting a line of text from the user
3109            / and chopping that line of text up into pieces.
3110            / 
3111            / The project-specific dictionary must provide a definition for
3112            / INBUF, an array of at least 81 bytes (count byte, 79 character
3113            / bytes, and space for the terminating NULL required by TOKEN).
3114            / 
3115            / ----
3116            / --	?ABORT - Aborts if a key has been typed at the console
3117            / 
3118            / ( -> )
3119            / 
3120            / This word is handy for the bottom of a scope loop. It will break out
3121            / of whatever is going on if a key is available at the console.
3122            
3123            
3124            / ----	?ABORT -- word # 54
3125            
3126            W54Name,
3127            
3128            	/ stringengize( ?ABORT )
3129 02740 0077 77
3130 02741 0101 101
3131 02742 0102 102
3132 02743 0117 117
3133 02744 0122 122
3134 02745 0124 124
3135            
3136 02746 0006 	.+0-W54Name
3137 02747 0020 	W54CFA-W53CFA
3138            W54CFA,
3139 02750 6311 	W4CFA-.		/ (:)
3140            W54PFA,
3141 02751 3242 	W55CFA-.		/ ?KEY
3142 02752 6465 	W10CFA-.		/ (0BRANCH)
3143 02753 0002 	W540-.
3144 02754 1731 	W56CFA-.		/ ABORT
3145            W540,
3146 02755 6332 	W5CFA-.		/ (;)
3147            / --	CR - Displays a carriage return on the console
3148            / 
3149            / ( -> )
3150            
3151            
3152            / ----	CR -- word # 57
3153            
3154            W57Name,
3155            
3156            	/ stringengize( CR )
3157 02756 0103 103
3158 02757 0122 122
3159            
3160 02760 0002 	.+0-W57Name
3161 02761 0012 	W57CFA-W54CFA
3162            W57CFA,
3163 02762 6277 	W4CFA-.		/ (:)
3164            W57PFA,
3165 02763 7545 	W40CFA-.		/ (LIT)
3166 02764 0015 	15		/ 13
3167 02765 3212 	W47CFA-.		/ EMIT
3168 02766 6321 	W5CFA-.		/ (;)
3169            / --	NL - Displays a newline ( <CR><LF> ) on the console
3170            / 
3171            / ( -> )
3172            
3173            
3174            / ----	NL -- word # 58
3175            
3176            W58Name,
3177            
3178            	/ stringengize( NL )
3179 02767 0116 116
3180 02770 0114 114
3181            
3182 02771 0002 	.+0-W58Name
3183 02772 0011 	W58CFA-W57CFA
3184            W58CFA,
3185 02773 6266 	W4CFA-.		/ (:)
3186            W58PFA,
3187 02774 7766 	W57CFA-.		/ CR
3188 02775 7533 	W40CFA-.		/ (LIT)
3189 02776 0012 	12		/ 10
3190 02777 3200 	W47CFA-.		/ EMIT
3191 03000 6307 	W5CFA-.		/ (;)
3192            
3193            
3194            / ----	INBUF -- word # 59
3195            
3196            W59Name,
3197            
3198            	/ stringengize( INBUF )
3199 03001 0111 111
3200 03002 0116 116
3201 03003 0102 102
3202 03004 0125 125
3203 03005 0106 106
3204            
3205 03006 0005 	.+0-W59Name
3206 03007 0015 	W59CFA-W58CFA
3207            W59CFA,
3208 03010 6354 	W7CFA-.		/ (VAR)
3209            W59PFA,
3210 03011 0000 	0
3211 03012 0000 	0
3212 03013 0000 	0
3213 03014 0000 	0
3214 03015 0000 	0
3215 03016 0000 	0
3216 03017 0000 	0
3217 03020 0000 	0
3218 03021 0000 	0
3219 03022 0000 	0
3220 03023 0000 	0
3221 03024 0000 	0
3222 03025 0000 	0
3223 03026 0000 	0
3224 03027 0000 	0
3225 03030 0000 	0
3226 03031 0000 	0
3227 03032 0000 	0
3228 03033 0000 	0
3229 03034 0000 	0
3230 03035 0000 	0
3231 03036 0000 	0
3232 03037 0000 	0
3233 03040 0000 	0
3234 03041 0000 	0
3235 03042 0000 	0
3236 03043 0000 	0
3237 03044 0000 	0
3238 03045 0000 	0
3239 03046 0000 	0
3240 03047 0000 	0
3241 03050 0000 	0
3242 03051 0000 	0
3243 03052 0000 	0
3244 03053 0000 	0
3245 03054 0000 	0
3246 03055 0000 	0
3247 03056 0000 	0
3248 03057 0000 	0
3249 03060 0000 	0
3250 03061 0000 	0
3251 03062 0000 	0
3252 03063 0000 	0
3253 03064 0000 	0
3254 03065 0000 	0
3255 03066 0000 	0
3256 03067 0000 	0
3257 03070 0000 	0
3258 03071 0000 	0
3259 03072 0000 	0
3260 03073 0000 	0
3261 03074 0000 	0
3262 03075 0000 	0
3263 03076 0000 	0
3264 03077 0000 	0
3265 03100 0000 	0
3266 03101 0000 	0
3267 03102 0000 	0
3268 03103 0000 	0
3269 03104 0000 	0
3270 03105 0000 	0
3271 03106 0000 	0
3272 03107 0000 	0
3273 03110 0000 	0
3274 03111 0000 	0
3275 03112 0000 	0
3276 03113 0000 	0
3277 03114 0000 	0
3278 03115 0000 	0
3279 03116 0000 	0
3280 03117 0000 	0
3281 03120 0000 	0
3282 03121 0000 	0
3283 03122 0000 	0
3284 03123 0000 	0
3285 03124 0000 	0
3286 03125 0000 	0
3287 03126 0000 	0
3288 03127 0000 	0
3289 03130 0000 	0
3290 03131 0000 	0
3291            
3292            
3293            / ----	IN -- word # 60
3294            
3295            W60Name,
3296            
3297            	/ stringengize( IN )
3298 03132 0111 111
3299 03133 0116 116
3300            
3301 03134 0002 	.+0-W60Name
3302 03135 0126 	W60CFA-W59CFA
3303            W60CFA,
3304 03136 6226 	W7CFA-.		/ (VAR)
3305            W60PFA,
3306 03137 0000 	0
3307            / --	GETLINE - Accept a line of input from the console.
3308            / 
3309            / This word reads a line of input from the console, storing it in the
3310            / string array INBUF. INBUF is arranged as a standard counted string;
3311            / the first byte ( INBUF B@ ) is the length of the line and the
3312            / remaining bytes are the data from the line.
3313            / 
3314            / The only control chracters recognized are <CR>, <BS>, and <DEL>.
3315            / All other control characters are ignored.
3316            / 
3317            / Revisions:
3318            / 
3319            / 06/25/96 RLI - State K was drawn with its decision backwards (i.e.,
3320            / 	it was going to state L if it received a non-control char).
3321            / 06/26/96 RLI - Changed state R's CR to an NL. MOved a DUP in state
3322            / 	D.
3323            / 07/23/96 RLI - Typo in state F.
3324            
3325            
3326            / ----	GETLINE -- word # 61
3327            
3328            W61Name,
3329            
3330            	/ stringengize( GETLINE )
3331 03140 0107 107
3332 03141 0105 105
3333 03142 0124 124
3334 03143 0114 114
3335 03144 0111 111
3336 03145 0116 116
3337 03146 0105 105
3338            
3339 03147 0007 	.+0-W61Name
3340 03150 0013 	W61CFA-W60CFA
3341            W61CFA,
3342 03151 6110 	W4CFA-.		/ (:)
3343            W61PFA,
3344            / State A: iNitialize the current pointer into the INBUF array. IN
3345            / contains the offset of the next byte to be stored into INBUF.
3346            W61a,
3347 03152 7356 	W40CFA-.		/ (LIT)
3348 03153 0001 	1		/ 1
3349 03154 7762 	W60CFA-.		/ IN
3350 03155 6434 	W16CFA-.		/ !
3351            / State B: Accept input when we're at the beginning of the line.
3352            / 
3353            / At the beginning of the line, <BS> and <DEL> have no meaning; they
3354            / need to be ignored. When one comes in, go to state C to decide
3355            / whether it should be ignored. Non-control charactrs need to be
3356            / accepted into the buffer; when one comes in, go to state D.
3357            W61b,
3358 03156 3061 	W62CFA-.		/ KEY
3359 03157 0200 	W63CFA-.		/ ISCONTROL
3360 03160 6257 	W10CFA-.		/ (0BRANCH)
3361 03161 0010 	W61d-.
3362            / State C: A control character has arrived when we're at the beginning
3363            / of the line. The only character of interest is <CR>; if the 
3364            / character is <CR>, go to state R. Otherwise, go back to state B
3365            / without doing anything with the control character.
3366            W61c,
3367 03162 7346 	W40CFA-.		/ (LIT)
3368 03163 0015 	15		/ 13
3369 03164 7014 	W32CFA-.		/ -
3370 03165 6252 	W10CFA-.		/ (0BRANCH)
3371 03166 0135 	W61r-.
3372 03167 6225 	W8CFA-.		/ (BRANCH)
3373 03170 7766 	W61b-.
3374            / State D: We've received a non-control character. Append it to the
3375            / buffer and bump the pointer into the buffer. If the pointer has gone
3376            / past position 79 (we don't have to have to worry about whether or
3377            / not the terminal wrapped), go to state E. Otherwise, go to state K.
3378            W61d,
3379 03171 6545 	W20CFA-.		/ DUP
3380 03172 7744 	W60CFA-.		/ IN
3381 03173 6334 	W12CFA-.		/ @
3382 03174 7614 	W59CFA-.		/ INBUF
3383 03175 7047 	W22CFA-.		/ +
3384 03176 6443 	W17CFA-.		/ B!
3385 03177 3000 	W47CFA-.		/ EMIT
3386 03200 7736 	W60CFA-.		/ IN
3387 03201 6520 	W19CFA-.		/ ++
3388 03202 7734 	W60CFA-.		/ IN
3389 03203 6324 	W12CFA-.		/ @
3390 03204 7324 	W40CFA-.		/ (LIT)
3391 03205 0117 	117		/ 79
3392 03206 7263 	W42CFA-.		/ >
3393 03207 6230 	W10CFA-.		/ (0BRANCH)
3394 03210 0034 	W61k-.
3395            / State E: Accept input when we're at the end of the line.
3396            / 
3397            / At the end of the line, only the control characters have meaning.
3398            / Since there's no space left in the buffer to store printing
3399            / characters, we'll just ignore them. When one comes in, go to state
3400            / F. When a control character comes in, go to state G.
3401            W61e,
3402 03211 3026 	W62CFA-.		/ KEY
3403 03212 0145 	W63CFA-.		/ ISCONTROL
3404 03213 7267 	W43CFA-.		/ 0=
3405 03214 6223 	W10CFA-.		/ (0BRANCH)
3406 03215 0004 	W61g-.
3407            / State F: Ignore a printing character at the end of the line.
3408            / 
3409            / We've received a printing character at the end of the line. There's
3410            / no space for it in the buffer, so just toss it and go back to
3411            / state E.
3412            W61f,
3413 03216 6573 	W24CFA-.		/ DROP
3414 03217 6175 	W8CFA-.		/ (BRANCH)
3415 03220 7771 	W61e-.
3416            / State G: We have a control character at the end of the line. Look
3417            / to see if it's <CR>; if so, go to state Q. Otherwise, go to
3418            / state H.
3419            W61g,
3420 03221 6515 	W20CFA-.		/ DUP
3421 03222 7306 	W40CFA-.		/ (LIT)
3422 03223 0015 	15		/ 13
3423 03224 6754 	W32CFA-.		/ -
3424 03225 6212 	W10CFA-.		/ (0BRANCH)
3425 03226 0074 	W61q-.
3426            / State H: It's not <CR>. check for <BS>. If it's <BS>, go to state P.
3427            / Otherwise, go to state I.
3428            W61h,
3429 03227 6507 	W20CFA-.		/ DUP
3430 03230 7300 	W40CFA-.		/ (LIT)
3431 03231 0010 	10		/ 8
3432 03232 6746 	W32CFA-.		/ -
3433 03233 6204 	W10CFA-.		/ (0BRANCH)
3434 03234 0063 	W61p-.
3435            / State I: It's not <BS>. Check for <DEL>. If it's <DEL>, go to state
3436            / O. Otherwise, go back to state E.
3437            W61i,
3438 03235 7273 	W40CFA-.		/ (LIT)
3439 03236 0177 	177		/ 127
3440 03237 6741 	W32CFA-.		/ -
3441 03240 6177 	W10CFA-.		/ (0BRANCH)
3442 03241 0031 	W61o-.
3443 03242 6152 	W8CFA-.		/ (BRANCH)
3444 03243 7746 	W61e-.
3445            / State J: (deleted)
3446            / State K: Accept a character in the middle of the buffer. All of the
3447            / control characters and printing characters have meaning. If a
3448            / control character comes in, go to state L. Otherwise, go to
3449            / state D.
3450            W61k,
3451 03244 2773 	W62CFA-.		/ KEY
3452 03245 0112 	W63CFA-.		/ ISCONTROL
3453 03246 6171 	W10CFA-.		/ (0BRANCH)
3454 03247 7722 	W61d-.
3455            / State L: We've received a control character in the middle of the
3456            / buffer. Look to see if it's <CR>. If so, go to staet Q. Otherwise,
3457            / go to state M.
3458            W61l,
3459 03250 6466 	W20CFA-.		/ DUP
3460 03251 7257 	W40CFA-.		/ (LIT)
3461 03252 0015 	15		/ 13
3462 03253 6725 	W32CFA-.		/ -
3463 03254 6163 	W10CFA-.		/ (0BRANCH)
3464 03255 0045 	W61q-.
3465            / State M: Look to see if it's <BS>. If so, go to state P. Otherwise,
3466            / go to state N.
3467            W61m,
3468 03256 6460 	W20CFA-.		/ DUP
3469 03257 7251 	W40CFA-.		/ (LIT)
3470 03260 0010 	10		/ 8
3471 03261 6717 	W32CFA-.		/ -
3472 03262 6155 	W10CFA-.		/ (0BRANCH)
3473 03263 0034 	W61p-.
3474            / State N: Look to see if it's <DEL>. If so, go to state O. Otherwise,
3475            / go to state K.
3476            W61n,
3477 03264 7244 	W40CFA-.		/ (LIT)
3478 03265 0177 	177		/ 127
3479 03266 6712 	W32CFA-.		/ -
3480 03267 7213 	W43CFA-.		/ 0=
3481 03270 6147 	W10CFA-.		/ (0BRANCH)
3482 03271 7753 	W61k-.
3483            / State O: We've received either a <BS> or a <DEL>. Echo <BS> <BS> to
3484            / erase the last printable character from the screen. Decrement IN to
3485            / erase the last printable character from INBUF. If IN has gone to
3486            / the beginning of the line, go to state B. Otherwise, go to state K.
3487            W61o,
3488 03272 7236 	W40CFA-.		/ (LIT)
3489 03273 0010 	10		/ 8
3490 03274 6442 	W20CFA-.		/ DUP
3491 03275 2702 	W47CFA-.		/ EMIT
3492 03276 7232 	W40CFA-.		/ (LIT)
3493 03277 0040 	40		/ 32
3494 03300 2677 	W47CFA-.		/ EMIT
3495 03301 2676 	W47CFA-.		/ EMIT
3496 03302 7634 	W60CFA-.		/ IN
3497 03303 6224 	W12CFA-.		/ @
3498 03304 7255 	W21CFA-.		/ 1
3499 03305 6673 	W32CFA-.		/ -
3500 03306 6430 	W20CFA-.		/ DUP
3501 03307 7627 	W60CFA-.		/ IN
3502 03310 6301 	W16CFA-.		/ !
3503 03311 7250 	W21CFA-.		/ 1
3504 03312 6666 	W32CFA-.		/ -
3505 03313 6124 	W10CFA-.		/ (0BRANCH)
3506 03314 7642 	W61b-.
3507 03315 6077 	W8CFA-.		/ (BRANCH)
3508 03316 7726 	W61k-.
3509            / State P: We've received a <BS>. We need to go to state O, but we've
3510            / still got the character on the stack so it could be checked for
3511            / <DEL> if it wasn't <BS>. Drop the character from the stack and go
3512            / to state O.
3513            W61p,
3514 03317 6472 	W24CFA-.		/ DROP
3515 03320 6074 	W8CFA-.		/ (BRANCH)
3516 03321 7751 	W61o-.
3517            / State Q: We've received a <CR>. We need to go to state R, but we've
3518            / still got the character on the stack so it could be checked for
3519            / <BS> and <DEL> if it wasn't <CR>. Drop the character from the stack
3520            / and go to state R.
3521            W61q,
3522 03322 6467 	W24CFA-.		/ DROP
3523            / State R: We're done. Ensure the line is null-termianted becasue
3524            / TOKEN requires this. Update the count byte of INBUF from IN; since
3525            / IN points at the _next_ character that would be filled by a non-
3526            / printing character, the number of characters in INBUF is IN-1.
3527            / 
3528            / After we're done, IN is initialized to 1 to make TOKEN's life
3529            / easier.
3530            W61r,
3531 03323 7231 	W44CFA-.		/ 0
3532 03324 7612 	W60CFA-.		/ IN
3533 03325 6202 	W12CFA-.		/ @
3534 03326 7462 	W59CFA-.		/ INBUF
3535 03327 6715 	W22CFA-.		/ +
3536 03330 6311 	W17CFA-.		/ B!
3537 03331 7605 	W60CFA-.		/ IN
3538 03332 6175 	W12CFA-.		/ @
3539 03333 7226 	W21CFA-.		/ 1
3540 03334 6644 	W32CFA-.		/ -
3541 03335 7453 	W59CFA-.		/ INBUF
3542 03336 6303 	W17CFA-.		/ B!
3543 03337 7222 	W21CFA-.		/ 1
3544 03340 7576 	W60CFA-.		/ IN
3545 03341 6250 	W16CFA-.		/ !
3546 03342 7431 	W58CFA-.		/ NL
3547            W61z,
3548 03343 5744 	W5CFA-.		/ (;)
3549            / --	ISCONTROL - See if an ASCII character is a control character
3550            / 
3551            / ( c -> c f )
3552            / 
3553            / f = 0 if c is not a control character
3554            / f = 1 if c is a control character
3555            / 
3556            / A control character is either smaller than ` ' or <DEL>.
3557            / 
3558            / Revisions:
3559            / 
3560            / 06/25/96 RLI - Ambiguous state diagramming turned into an oops in
3561            / 	state A. Swapped states B and C to compensate without
3562            / 	adding extra code.
3563            
3564            
3565            / ----	ISCONTROL -- word # 63
3566            
3567            W63Name,
3568            
3569            	/ stringengize( ISCONTROL )
3570 03344 0111 111
3571 03345 0123 123
3572 03346 0103 103
3573 03347 0117 117
3574 03350 0116 116
3575 03351 0124 124
3576 03352 0122 122
3577 03353 0117 117
3578 03354 0114 114
3579            
3580 03355 0011 	.+0-W63Name
3581 03356 0206 	W63CFA-W61CFA
3582            W63CFA,
3583 03357 5702 	W4CFA-.		/ (:)
3584            W63PFA,
3585            / State A: Look to see if it's smaller than ' '. If so, go to C.
3586            / Otherwise, go to B.
3587            W63a,
3588 03360 6356 	W20CFA-.		/ DUP
3589 03361 7147 	W40CFA-.		/ (LIT)
3590 03362 0040 	40		/ 32
3591 03363 7077 	W41CFA-.		/ <
3592 03364 6053 	W10CFA-.		/ (0BRANCH)
3593 03365 0004 	W63c-.
3594            / State B: It's smaller than ' ', but we lost that fact when we did
3595            / the (0BRANCH). Push a true back on the stack and exit.
3596            W63b,
3597 03366 7173 	W21CFA-.		/ 1
3598 03367 6025 	W8CFA-.		/ (BRANCH)
3599 03370 0005 	W63z-.
3600            / State C: It's not smaller than ' '; is it <DEL>? Check and exit.
3601            W63c,
3602 03371 6345 	W20CFA-.		/ DUP
3603 03372 7136 	W40CFA-.		/ (LIT)
3604 03373 0177 	177		/ 127
3605 03374 7121 	W45CFA-.		/ =
3606            W63z,
3607 03375 5712 	W5CFA-.		/ (;)
3608            / --	NEXTCHAR - Returns the next character from the input buffer
3609            / 
3610            / ( -> c )
3611            / 
3612            / The character at INBUF[ IN ] is fetched. IN is bumped if the
3613            / character was not null.
3614            
3615            
3616            / ----	NEXTCHAR -- word # 64
3617            
3618            W64Name,
3619            
3620            	/ stringengize( NEXTCHAR )
3621 03376 0116 116
3622 03377 0105 105
3623 03400 0130 130
3624 03401 0124 124
3625 03402 0103 103
3626 03403 0110 110
3627 03404 0101 101
3628 03405 0122 122
3629            
3630 03406 0010 	.+0-W64Name
3631 03407 0031 	W64CFA-W63CFA
3632            W64CFA,
3633 03410 5651 	W4CFA-.		/ (:)
3634            W64PFA,
3635 03411 7377 	W59CFA-.		/ INBUF
3636 03412 7524 	W60CFA-.		/ IN
3637 03413 6114 	W12CFA-.		/ @
3638 03414 6630 	W22CFA-.		/ +
3639 03415 6126 	W13CFA-.		/ B@
3640 03416 6320 	W20CFA-.		/ DUP
3641 03417 6020 	W10CFA-.		/ (0BRANCH)
3642 03420 0003 	W640-.
3643 03421 7515 	W60CFA-.		/ IN
3644 03422 6277 	W19CFA-.		/ ++
3645            W640,
3646 03423 5664 	W5CFA-.		/ (;)
3647            / --	TOKEN - return the next token from INBUF
3648            / 
3649            / ( -> a c )
3650            / 
3651            / This word looks at the next string from INBUF to find the next
3652            / token. Blanks are skipped until a non-blank is found; the address
3653            / of the first non-blank is 'a'. The non-blanks are then counted until
3654            / a blank is found; the count of non-blanks is 'c'.
3655            / 
3656            / NEXTCHAR is used to fetch characters from INBUF. NEXTCHAR uses IN
3657            / to tell it where the next character is and updates IN after it
3658            / fetches a character. Both NEXTCHAR and TOKEN assume there is a
3659            / null following INBUF.
3660            / 
3661            / TOKEN assumes the only whitespace characters it will encounter
3662            / in INBUF are NULL and space.
3663            
3664            
3665            / ----	TOKEN -- word # 65
3666            
3667            W65Name,
3668            
3669            	/ stringengize( TOKEN )
3670 03424 0124 124
3671 03425 0117 117
3672 03426 0113 113
3673 03427 0105 105
3674 03430 0116 116
3675            
3676 03431 0005 	.+0-W65Name
3677 03432 0023 	W65CFA-W64CFA
3678            W65CFA,
3679 03433 5626 	W4CFA-.		/ (:)
3680            W65PFA,
3681            / State A: Form the address of the first character we'll examine and
3682            / go to state B.
3683            W65a,
3684 03434 7354 	W59CFA-.		/ INBUF
3685 03435 7501 	W60CFA-.		/ IN
3686 03436 6071 	W12CFA-.		/ @
3687 03437 6605 	W22CFA-.		/ +
3688            / State B: We've not yet seen a non-space character.
3689            / 
3690            / Get the next character and check for the null terminator. If we've
3691            / hit the null terminator, just exit; the copy of the null we would
3692            / need for state C if it weren't null will be a zero to tell the
3693            / caller that we hit the null before seeing anything. If the
3694            / character is not null, go to state C.
3695            W65b,
3696 03440 7750 	W64CFA-.		/ NEXTCHAR
3697 03441 6275 	W20CFA-.		/ DUP
3698 03442 5775 	W10CFA-.		/ (0BRANCH)
3699 03443 0031 	W65z-.
3700            / State C: It's not a null, look for a space. If it's a space, go to
3701            / state H. Otherwise, go to state D.
3702            W65c,
3703 03444 7064 	W40CFA-.		/ (LIT)
3704 03445 0040 	40		/ 32
3705 03446 6532 	W32CFA-.		/ -
3706 03447 5770 	W10CFA-.		/ (0BRANCH)
3707 03450 0017 	W65h-.
3708            / State D: We've found our first non-space character. The token is
3709            / at least one character long. Put the initial count on the stack
3710            / and go to state E.
3711            W65d,
3712 03451 7110 	W21CFA-.		/ 1
3713            / State E: Get the next character and look to see if it's the null
3714            / at the end of the buffer. If so, go to state I. Otherwise, go to
3715            / state F.
3716            W65e,
3717 03452 7736 	W64CFA-.		/ NEXTCHAR
3718 03453 6263 	W20CFA-.		/ DUP
3719 03454 5763 	W10CFA-.		/ (0BRANCH)
3720 03455 0016 	W65i-.
3721            / State F: We've not found the end of the string, but have we found
3722            / the end of the token? If the character is space, exit; the correct
3723            / count will be on top of the stack. Otherwise, go to state G.
3724            W65f,
3725 03456 7052 	W40CFA-.		/ (LIT)
3726 03457 0040 	40		/ 32
3727 03460 6520 	W32CFA-.		/ -
3728 03461 5756 	W10CFA-.		/ (0BRANCH)
3729 03462 0012 	W65z-.
3730            / State G: We have another non-space character. Count it and go back
3731            / to state E.
3732            W65g,
3733 03463 7076 	W21CFA-.		/ 1
3734 03464 6560 	W22CFA-.		/ +
3735 03465 5727 	W8CFA-.		/ (BRANCH)
3736 03466 7764 	W65e-.
3737            / State H: We have another space character before the token. Bump the
3738            / pointer to the first non-space character and go back to state B.
3739            W65h,
3740 03467 7072 	W21CFA-.		/ 1
3741 03470 6554 	W22CFA-.		/ +
3742 03471 5723 	W8CFA-.		/ (BRANCH)
3743 03472 7746 	W65b-.
3744            / State I: We've found the null at the end of the buffer immediately
3745            / following the token. We have an extry copy of the null on the stack
3746            / so that state F could check for a space. Drop the extra copy and
3747            / exit.
3748            W65i,
3749 03473 6316 	W24CFA-.		/ DROP
3750            / *** EXIT ***
3751            W65z,
3752 03474 5613 	W5CFA-.		/ (;)
3753            / ----
3754            / 
3755            / String comparisons
3756            / 
3757            / These are primarily used when looking up a word in the dictionary
3758            / 
3759            / ----
3760            / --	$= - String comparison
3761            / 
3762            / ( a2 c2 a1 c1 -> f )
3763            / 
3764            / 'f' is 0 if the string described by a1,c1 is not equal to the
3765            / string described by a2,c2. 'f' is 1 if they are equal.
3766            
3767            
3768            / ----	$= -- word # 66
3769            
3770            W66Name,
3771            
3772            	/ stringengize( $= )
3773 03475 0044 44
3774 03476 0075 75
3775            
3776 03477 0002 	.+0-W66Name
3777 03500 0046 	W66CFA-W65CFA
3778            W66CFA,
3779 03501 5560 	W4CFA-.		/ (:)
3780            W66PFA,
3781            / State A: Compare the lengths of the strings; if the strings are
3782            / equal, they must have the same length. If the lengths differ,
3783            / go to stae E. Othewrise, go to state B.
3784            W66a,
3785 03502 6256 	W23CFA-.		/ SWAP
3786 03503 6323 	W25CFA-.		/ >R
3787 03504 6431 	W29CFA-.		/ OVER
3788 03505 6473 	W32CFA-.		/ -
3789 03506 6774 	W43CFA-.		/ 0=
3790 03507 5730 	W10CFA-.		/ (0BRANCH)
3791 03510 0034 	W66e-.
3792            / State B: Arrange the stack such that the number of characters to be
3793            / compared is the top of the math staack and the addresses of the two
3794            / strings are next on the math stack. If the number of characters to
3795            / compare is zero, we're trying to compare two null strings; go to
3796            / state F since the strings are obviously equal. Otherwise, go to 
3797            / state C.
3798            W66b,
3799 03511 6344 	W26CFA-.		/ <R
3800 03512 6246 	W23CFA-.		/ SWAP
3801 03513 6223 	W20CFA-.		/ DUP
3802 03514 5723 	W10CFA-.		/ (0BRANCH)
3803 03515 0036 	W66f-.
3804            / State C: Stash the number of characters to compare on the return
3805            / stack where it'll be safe for a moment. Fetch the next character
3806            / from both strings and compare that character. If they are equal,
3807            / go to state D. Otherwise, go to state E.
3808            W66c,
3809 03516 6310 	W25CFA-.		/ >R
3810 03517 6416 	W29CFA-.		/ OVER
3811 03520 6023 	W13CFA-.		/ B@
3812 03521 6414 	W29CFA-.		/ OVER
3813 03522 6021 	W13CFA-.		/ B@
3814 03523 6455 	W32CFA-.		/ -
3815 03524 6756 	W43CFA-.		/ 0=
3816 03525 5712 	W10CFA-.		/ (0BRANCH)
3817 03526 0016 	W66e-.
3818            / State D: The strings are equal so far. Bump the pointers into the
3819            / strings and decrement the count of characters left to compare.
3820            / If we've compared all of the characters, go to state F. Otherwise,
3821            / go to state B.
3822            W66d,
3823 03527 7032 	W21CFA-.		/ 1
3824 03530 6514 	W22CFA-.		/ +
3825 03531 6227 	W23CFA-.		/ SWAP
3826 03532 7027 	W21CFA-.		/ 1
3827 03533 6511 	W22CFA-.		/ +
3828 03534 6321 	W26CFA-.		/ <R
3829 03535 7024 	W21CFA-.		/ 1
3830 03536 6442 	W32CFA-.		/ -
3831 03537 6177 	W20CFA-.		/ DUP
3832 03540 5677 	W10CFA-.		/ (0BRANCH)
3833 03541 0012 	W66f-.
3834 03542 5652 	W8CFA-.		/ (BRANCH)
3835 03543 7753 	W66c-.
3836            / State E: We've found a difference between the strings; they aren't
3837            / equal. Clean up the math and return stacks and push a zero onto
3838            / the math stack to indicate the inequality. Exit.
3839            W66e,
3840 03544 6311 	W26CFA-.		/ <R
3841 03545 6244 	W24CFA-.		/ DROP
3842 03546 6243 	W24CFA-.		/ DROP
3843 03547 6242 	W24CFA-.		/ DROP
3844 03550 7004 	W44CFA-.		/ 0
3845 03551 5643 	W8CFA-.		/ (BRANCH)
3846 03552 0005 	W66z-.
3847            / State F: We've made it to the end of the strings without finding a
3848            / difference; they must be equal. Clean up the math stack and push a
3849            / 1 to indicate the equality. Exit.
3850            W66f,
3851 03553 6236 	W24CFA-.		/ DROP
3852 03554 6235 	W24CFA-.		/ DROP
3853 03555 6234 	W24CFA-.		/ DROP
3854 03556 7003 	W21CFA-.		/ 1
3855            / *** EXIT ***
3856            W66z,
3857 03557 5530 	W5CFA-.		/ (;)
3858            / ----
3859            / 
3860            / Simple directory manipulation
3861            / 
3862            / ----
3863            
3864            
3865            / ----	LAST -- word # 67
3866            
3867            W67Name,
3868            
3869            	/ stringengize( LAST )
3870 03560 0114 114
3871 03561 0101 101
3872 03562 0123 123
3873 03563 0124 124
3874            
3875 03564 0004 	.+0-W67Name
3876 03565 0065 	W67CFA-W66CFA
3877            W67CFA,
3878 03566 5576 	W7CFA-.		/ (VAR)
3879            W67PFA,
3880 03567 0000 	0
3881            / --	ID>$ - Turn a word name into a counted string description
3882            / 
3883            / ( cfa -> a c )
3884            / 
3885            / Given the address of a word's CFA, this word returns the address of
3886            / the word's name (a) and the length of the word's name (c).
3887            / 
3888            / Revisions:
3889            / 
3890            / 06/26/96 RLI - Number of small oopses. First, the value for
3891            / 	%flagoffset is given as a byte offset from the CFA. This
3892            / 	value is negative, so we need to _add_ it to the CFA instead
3893            / 	of subtracting it. Second, the SWAP was accidentally omitted
3894            / 	from state A. Third, the SWAP in stateh C was not necessary
3895            / 	as the address of the name is smaller than the address of
3896            / 	the end of the string, not vice-versa.
3897            
3898            
3899            / ----	ID>$ -- word # 68
3900            
3901            W68Name,
3902            
3903            	/ stringengize( ID>$ )
3904 03570 0111 111
3905 03571 0104 104
3906 03572 0076 76
3907 03573 0044 44
3908            
3909 03574 0004 	.+0-W68Name
3910 03575 0010 	W68CFA-W67CFA
3911            W68CFA,
3912 03576 5463 	W4CFA-.		/ (:)
3913            W68PFA,
3914            / State A: Given the CFA, calculate the address of the word's name.
3915            / First calculate the address of the flags byte (which contains the
3916            / name's length) then fetch the flags byte and strip off the flags.
3917            / From that, calculate the address of the start of the word's name.
3918            / 
3919            / Since a name may be padded with nulls to longword align the
3920            / definition, the length of the word's name given in the word's header
3921            / may not be the actual length of the word's name; we have to strip
3922            / any nulls that may follow the name.
3923            W68a,
3924 03577 6731 	W40CFA-.		/ (LIT)
3925 03600 7776 	37777777776		/ -2
3926 03601 6443 	W22CFA-.		/ +
3927 03602 6134 	W20CFA-.		/ DUP
3928 03603 6133 	W20CFA-.		/ DUP
3929 03604 5723 	W12CFA-.		/ @
3930 03605 6723 	W40CFA-.		/ (LIT)
3931 03606 0077 	77		/ 63
3932 03607 6466 	W34CFA-.		/ AND
3933 03610 6370 	W32CFA-.		/ -
3934 03611 6147 	W23CFA-.		/ SWAP
3935            / State B: Move to the previous character (the first time, this will
3936            / move from the Flag byte to the last byte of the name). If the new
3937            / character is a null, do it again. Otherwise, go to state C.
3938            W68b,
3939 03612 6747 	W21CFA-.		/ 1
3940 03613 6365 	W32CFA-.		/ -
3941 03614 6122 	W20CFA-.		/ DUP
3942 03615 5726 	W13CFA-.		/ B@
3943 03616 5621 	W10CFA-.		/ (0BRANCH)
3944 03617 7773 	W68b-.
3945            / State C: We've found the address of the last non-null character of
3946            / the name, now calculate the length of the name. Exit.
3947            W68c,
3948 03620 6315 	W29CFA-.		/ OVER
3949 03621 6357 	W32CFA-.		/ -
3950 03622 6737 	W21CFA-.		/ 1
3951 03623 6421 	W22CFA-.		/ +
3952            / *** EXIT ***
3953            W68z,
3954 03624 5463 	W5CFA-.		/ (;)
3955            / --	PREV - Return the address of the previous word's CFA
3956            / 
3957            / 	( cfa -> cfa )
3958            / 
3959            / Given the address of a word's CFA, this word will return either the
3960            / address of the CFA of the previous word in the dictionary or zero if
3961            / the given word is the first word in the dictionary.
3962            / 
3963            / Since this word returns zero when it encounters the first word, you
3964            / cannot have a word which has its CFA at address zero. Since there
3965            / are header items before the CFA, I don't think this is a problem.
3966            / 
3967            / Revisions:
3968            / 
3969            / 06/25/96 RLI - Fixed state C, which was coded to assume the CFA
3970            / 	address pointed to a 16-bit link field. Sigh.
3971            / 06/28/96 RLI - Modified to use cell-sized link field.
3972            
3973            
3974            / ----	PREV -- word # 69
3975            
3976            W69Name,
3977            
3978            	/ stringengize( PREV )
3979 03625 0120 120
3980 03626 0122 122
3981 03627 0105 105
3982 03630 0126 126
3983            
3984 03631 0004 	.+0-W69Name
3985 03632 0035 	W69CFA-W68CFA
3986            W69CFA,
3987 03633 5426 	W4CFA-.		/ (:)
3988            W69PFA,
3989            / State A: Fetch the flag word for this word and examine the End flag.
3990            / If it's set, go to state B. Otherwise, go to state C.
3991            W69a,
3992 03634 6102 	W20CFA-.		/ DUP
3993 03635 6673 	W40CFA-.		/ (LIT)
3994 03636 7776 	37777777776		/ -2
3995 03637 6405 	W22CFA-.		/ +
3996 03640 5667 	W12CFA-.		/ @
3997 03641 6667 	W40CFA-.		/ (LIT)
3998 03642 0100 	100		/ 64
3999 03643 6432 	W34CFA-.		/ AND
4000 03644 5573 	W10CFA-.		/ (0BRANCH)
4001 03645 0005 	W69c-.
4002            / State B: This is the first word in the dictionary. Return a zero.
4003            W69b,
4004 03646 6143 	W24CFA-.		/ DROP
4005 03647 6705 	W44CFA-.		/ 0
4006 03650 5544 	W8CFA-.		/ (BRANCH)
4007 03651 0007 	W69z-.
4008            / State C: This is not the first word in the dictionary. Fetch the
4009            / address of the previous word and exit.
4010            W69c,
4011 03652 6064 	W20CFA-.		/ DUP
4012 03653 6655 	W40CFA-.		/ (LIT)
4013 03654 7777 	37777777777		/ -1
4014 03655 6367 	W22CFA-.		/ +
4015 03656 5651 	W12CFA-.		/ @
4016 03657 6321 	W32CFA-.		/ -
4017            / *** EXIT ***
4018            W69z,
4019 03660 5427 	W5CFA-.		/ (;)
4020            / --	VLIST - Display the names of all words in the dictionary
4021            / 
4022            / ( -> )
4023            / 
4024            / This word traverses the dictionary, displaying the name of each
4025            / word in the dictionary.
4026            / 
4027            / Revisions:
4028            / 
4029            / 06/26/96 RLI - Added a space after each name is displayed.
4030            
4031            
4032            / ----	VLIST -- word # 70
4033            
4034            W70Name,
4035            
4036            	/ stringengize( VLIST )
4037 03661 0126 126
4038 03662 0114 114
4039 03663 0111 111
4040 03664 0123 123
4041 03665 0124 124
4042            
4043 03666 0005 	.+0-W70Name
4044 03667 0035 	W70CFA-W69CFA
4045            W70CFA,
4046 03670 5371 	W4CFA-.		/ (:)
4047            W70PFA,
4048            / State A: Begin at LAST. Go to state B.
4049            W70a,
4050 03671 7675 	W67CFA-.		/ LAST
4051 03672 5635 	W12CFA-.		/ @
4052            / State B: Look to see if we've found the end of the dictionary. If
4053            / so, go to state D. Otherwise, go to state C.
4054            W70b,
4055 03673 6043 	W20CFA-.		/ DUP
4056 03674 5543 	W10CFA-.		/ (0BRANCH)
4057 03675 0012 	W70d-.
4058            / State C: We've not found the end of the dictionary. Display this
4059            / word's name and move to the previous word. Go back to state B.
4060            W70c,
4061 03676 6040 	W20CFA-.		/ DUP
4062 03677 7677 	W68CFA-.		/ ID>$
4063 03700 7003 	W52CFA-.		/ TYPE
4064 03701 6627 	W40CFA-.		/ (LIT)
4065 03702 0040 	40		/ 32
4066 03703 2274 	W47CFA-.		/ EMIT
4067 03704 7727 	W69CFA-.		/ PREV
4068 03705 5507 	W8CFA-.		/ (BRANCH)
4069 03706 7765 	W70b-.
4070            / State D: We've found the end of the dictionary. Drop the zero from
4071            / the stack and exit.
4072            W70d,
4073 03707 6102 	W24CFA-.		/ DROP
4074            / *** EXIT ***
4075            W70z,
4076 03710 5377 	W5CFA-.		/ (;)
4077            / --	FIND - Find a word in the dictionary given its name
4078            / 
4079            / ( a c -> a c cfa )
4080            / 
4081            / Given a counted string containing the name of a word, this word
4082            / looks it up in the dictionary and returns its CFA. If the word is
4083            / not in the dictionary, zero is returned for the CFA.
4084            
4085            
4086            / ----	FIND -- word # 71
4087            
4088            W71Name,
4089            
4090            	/ stringengize( FIND )
4091 03711 0106 106
4092 03712 0111 111
4093 03713 0116 116
4094 03714 0104 104
4095            
4096 03715 0004 	.+0-W71Name
4097 03716 0027 	W71CFA-W70CFA
4098            W71CFA,
4099 03717 5342 	W4CFA-.		/ (:)
4100            W71PFA,
4101            / State A: Begin at the last word in the dictionary.
4102            W71a,
4103 03720 7646 	W67CFA-.		/ LAST
4104 03721 5606 	W12CFA-.		/ @
4105 03722 6104 	W25CFA-.		/ >R
4106            / State B: Take a look at the next word we're going to examine. If 
4107            / we've found the end of the dictionary, go to state D. Otherwise,
4108            / go to state C.
4109            W71b,
4110 03723 6156 	W27CFA-.		/ R
4111 03724 5513 	W10CFA-.		/ (0BRANCH)
4112 03725 0010 	W71d-.
4113            / State C: We've not found the word yet. Compare the string with the
4114            / word's name. If they matched, go to state D. Otherwise, go to state
4115            / E.
4116            W71c,
4117 03726 6207 	W29CFA-.		/ OVER
4118 03727 6206 	W29CFA-.		/ OVER
4119 03730 6151 	W27CFA-.		/ R
4120 03731 7645 	W68CFA-.		/ ID>$
4121 03732 7547 	W66CFA-.		/ $=
4122 03733 5504 	W10CFA-.		/ (0BRANCH)
4123 03734 0004 	W71e-.
4124            / State D: We've reached the end of the search; either we've found the
4125            / word (and the address of the word's CFA is on the return stack) or
4126            / we've hit the end of the dictionary (and zero is on the return
4127            / stack). In either case, we need to return whatever is on the
4128            / return stack; pop it into the math stack and exit.
4129            W71d,
4130 03735 6120 	W26CFA-.		/ <R
4131 03736 5456 	W8CFA-.		/ (BRANCH)
4132 03737 0006 	W71z-.
4133            / State E: This word didn't match. Advance to the previous word and go
4134            / to state B.
4135            W71e,
4136 03740 6115 	W26CFA-.		/ <R
4137 03741 7672 	W69CFA-.		/ PREV
4138 03742 6064 	W25CFA-.		/ >R
4139 03743 5451 	W8CFA-.		/ (BRANCH)
4140 03744 7757 	W71b-.
4141            / *** EXIT ***
4142            W71z,
4143 03745 5342 	W5CFA-.		/ (;)
4144            
4145            
4146            / ----	DIGITMAP -- word # 72
4147            
4148            W72Name,
4149            
4150            	/ stringengize( DIGITMAP )
4151 03746 0104 104
4152 03747 0111 111
4153 03750 0107 107
4154 03751 0111 111
4155 03752 0124 124
4156 03753 0115 115
4157 03754 0101 101
4158 03755 0120 120
4159            
4160 03756 0010 	.+0-W72Name
4161 03757 0041 	W72CFA-W71CFA
4162            W72CFA,
4163 03760 5404 	W7CFA-.		/ (VAR)
4164            W72PFA,
4165            / DIGITMAP
4166            / 
4167            / M: ( -> Address of DIGITMAP's definition )
4168            / R: ( -> )
4169            / 
4170            / DIGITMAP is a word containing a bitmap identifying characters as
4171            / being digits; a bit set in DIGITMAP indicates the character will be
4172            / identified as a digit.
4173            / 
4174            / Revisions:
4175            / 07/29/99 RLI - code version
4176            / Character codes 00 through 0f; control characters.
4177 03761 0000 	0
4178 03762 0000 	0
4179            / Character codes 01 through 1f; more control characters.
4180 03763 0000 	0
4181 03764 0000 	0
4182            / Character codes 20 through 2f; punctuation. '.' will be accepted as
4183            / a digit so it may be used as a separator for 32-bit hex numbers to make
4184            / typing them easier.
4185 03765 0000 	0
4186 03766 0100 	100
4187            / Character codes 30 through 3f; decimal digits and more punctuation
4188 03767 0377 	377
4189 03770 0003 	3
4190            / Character codes 40 through 4f; @ and uppercase letters
4191 03771 0176 	176
4192 03772 0000 	0
4193            / Character codes 50 through 5f; more uppercase letters
4194 03773 0000 	0
4195 03774 0000 	0
4196            / Character codes 60 through 6f; lower case letters
4197 03775 0176 	176
4198 03776 0000 	0
4199            / Character codes 70 through 7f; more lower case letters
4200 03777 0000 	0
4201 04000 0000 	0
4202            / --	ISDIGIT - Look to see if a character is a hexadecimal digit
4203            / 
4204            / ( c -> f )
4205            / 
4206            / 'f' is 0 if the character 'c' is not a hex digit. 'f' is non-zero
4207            / if 'c' is a hex digit.
4208            / 
4209            / ISDIGIT works by turning the character into a byte offset into
4210            / DIGITMAP and a bit mask for that byte. 'f' will actually be the
4211            / result of ANDingthe selected by of DIGITMAP with the bitmask
4212            / generated from 'c', so don't count on it being 1 if it's not 0.
4213            
4214            
4215            / ----	ISDIGIT -- word # 73
4216            
4217            W73Name,
4218            
4219            	/ stringengize( ISDIGIT )
4220 04001 0111 111
4221 04002 0123 123
4222 04003 0104 104
4223 04004 0111 111
4224 04005 0107 107
4225 04006 0111 111
4226 04007 0124 124
4227            
4228 04010 0007 	.+0-W73Name
4229 04011 0032 	W73CFA-W72CFA
4230            W73CFA,
4231 04012 5247 	W4CFA-.		/ (:)
4232            W73PFA,
4233 04013 5723 	W20CFA-.		/ DUP
4234 04014 6514 	W40CFA-.		/ (LIT)
4235 04015 0003 	3		/ 3
4236 04016 6404 	W38CFA-.		/ >>
4237 04017 5741 	W23CFA-.		/ SWAP
4238 04020 6510 	W40CFA-.		/ (LIT)
4239 04021 0007 	7		/ 7
4240 04022 6253 	W34CFA-.		/ AND
4241 04023 6536 	W21CFA-.		/ 1
4242 04024 5734 	W23CFA-.		/ SWAP
4243 04025 6345 	W37CFA-.		/ <<
4244 04026 5732 	W23CFA-.		/ SWAP
4245 04027 7731 	W72CFA-.		/ DIGITMAP
4246 04030 6214 	W22CFA-.		/ +
4247 04031 5512 	W13CFA-.		/ B@
4248 04032 6243 	W34CFA-.		/ AND
4249 04033 5254 	W5CFA-.		/ (;)
4250            / --	>NYBBLE - Convert a character to a binary hex nybble
4251            / 
4252            / ( c -> n )
4253            
4254            
4255            / ----	>NYBBLE -- word # 74
4256            
4257            W74Name,
4258            
4259            	/ stringengize( >NYBBLE )
4260 04034 0076 76
4261 04035 0116 116
4262 04036 0131 131
4263 04037 0102 102
4264 04040 0102 102
4265 04041 0114 114
4266 04042 0105 105
4267            
4268 04043 0007 	.+0-W74Name
4269 04044 0033 	W74CFA-W73CFA
4270            W74CFA,
4271 04045 5214 	W4CFA-.		/ (:)
4272            W74PFA,
4273            / State A: Look to see if we have a decimal digit or an alphabetic
4274            / hext digit. If we have a decimal digit, go to state C.
4275            W74a,
4276 04046 5670 	W20CFA-.		/ DUP
4277 04047 6461 	W40CFA-.		/ (LIT)
4278 04050 0100 	100		/ 64
4279 04051 6224 	W34CFA-.		/ AND
4280 04052 5365 	W10CFA-.		/ (0BRANCH)
4281 04053 0005 	W74c-.
4282            / State B: We have an alphabetix hex digit. We'll have to add 9 when
4283            / we're done to get the proper value. Go to state D.
4284            W74b,
4285 04054 6454 	W40CFA-.		/ (LIT)
4286 04055 0011 	11		/ 9
4287 04056 5336 	W8CFA-.		/ (BRANCH)
4288 04057 0002 	W74d-.
4289            / State C: We have a decimal digit. We'll have to add 0 when we're
4290            / done to get the proper value. Go to state D.
4291            W74c,
4292 04060 6474 	W44CFA-.		/ 0
4293            / State D: Extract the low nybble and add the fudge factor. Exit.
4294            W74d,
4295 04061 5677 	W23CFA-.		/ SWAP
4296 04062 6446 	W40CFA-.		/ (LIT)
4297 04063 0017 	17		/ 15
4298 04064 6211 	W34CFA-.		/ AND
4299 04065 6157 	W22CFA-.		/ +
4300            / *** EXIT ***
4301            W74z,
4302 04066 5221 	W5CFA-.		/ (;)
4303            / --	>NYBBLES - Convert a counted string to a binary integer
4304            / 
4305            / ( a c -> n )
4306            / 
4307            / This word assumes every character in the string is either a valid
4308            / digit or '.'; that is, it does not checking on the characters other
4309            / than skipping perios.
4310            / 
4311            / Revisions:
4312            / 
4313            / 06/26/96 RLI - Both state B and E were advancing the pointer into
4314            / 	the digit string.
4315            
4316            
4317            / ----	>NYBBLES -- word # 75
4318            
4319            W75Name,
4320            
4321            	/ stringengize( >NYBBLES )
4322 04067 0076 76
4323 04070 0116 116
4324 04071 0131 131
4325 04072 0102 102
4326 04073 0102 102
4327 04074 0114 114
4328 04075 0105 105
4329 04076 0123 123
4330            
4331 04077 0010 	.+0-W75Name
4332 04100 0034 	W75CFA-W74CFA
4333            W75CFA,
4334 04101 5160 	W4CFA-.		/ (:)
4335            W75PFA,
4336            / State A: Stuff an initial value for n (0) onto th emath stack and
4337            / start the do loop stuff. Go to state B.
4338            W75a,
4339 04102 6452 	W44CFA-.		/ 0
4340 04103 5655 	W23CFA-.		/ SWAP
4341 04104 6450 	W44CFA-.		/ 0
4342 04105 0332 	W49CFA-.		/ (DO)
4343            W750,
4344            / State B: We have to add another digit to the value. Fetch the
4345            / character to be converted and look to see if it's a '.'. If it is,
4346            / go to state D to ignore the character. Otherwise, go to state C.
4347            W75b,
4348 04106 6027 	W29CFA-.		/ OVER
4349 04107 5434 	W13CFA-.		/ B@
4350 04110 5626 	W20CFA-.		/ DUP
4351 04111 6417 	W40CFA-.		/ (LIT)
4352 04112 0056 	56		/ 46
4353 04113 6065 	W32CFA-.		/ -
4354 04114 5323 	W10CFA-.		/ (0BRANCH)
4355 04115 0011 	W75d-.
4356            / State C: We have a digit to convert. Convert the digit, make space
4357            / for the new nybble (by shifting the old value over a nybble), and
4358            / add the new nybble into the value. Go to state E.
4359            W75c,
4360 04116 7727 	W74CFA-.		/ >NYBBLE
4361 04117 5641 	W23CFA-.		/ SWAP
4362 04120 6410 	W40CFA-.		/ (LIT)
4363 04121 0004 	4		/ 4
4364 04122 6250 	W37CFA-.		/ <<
4365 04123 6121 	W22CFA-.		/ +
4366 04124 5270 	W8CFA-.		/ (BRANCH)
4367 04125 0002 	W75e-.
4368            / State D: We need to ignore this character. Drop it from the stack
4369            / and go to state E.
4370            W75d,
4371 04126 5663 	W24CFA-.		/ DROP
4372            / State E: Bump the address from which we will fetch the next
4373            / character. If we're not done, go to state B. Otherwise, go to
4374            / state F.
4375            W75e,
4376 04127 5631 	W23CFA-.		/ SWAP
4377 04130 6431 	W21CFA-.		/ 1
4378 04131 6113 	W22CFA-.		/ +
4379 04132 5626 	W23CFA-.		/ SWAP
4380 04133 0161 	W50CFA-.		/ (LOOP)
4381 04134 7752 	W750-.
4382            / State F: We're done. Drop the character address from the stack and
4383            / exit.
4384            W75f,
4385 04135 5623 	W23CFA-.		/ SWAP
4386 04136 5653 	W24CFA-.		/ DROP
4387            / *** EXIT ***
4388            W75z,
4389 04137 5150 	W5CFA-.		/ (;)
4390            / --	ISNUMBER - Examine a counted string to see if it's a number
4391            / 
4392            / ( a c -> a c f )
4393            / 
4394            / 'f' is 0 if any character in the string is not a digit. 'f'. is a 1
4395            / if all characters in the string are digits.
4396            
4397            
4398            / ----	ISNUMBER -- word # 76
4399            
4400            W76Name,
4401            
4402            	/ stringengize( ISNUMBER )
4403 04140 0111 111
4404 04141 0123 123
4405 04142 0116 116
4406 04143 0125 125
4407 04144 0115 115
4408 04145 0102 102
4409 04146 0105 105
4410 04147 0122 122
4411            
4412 04150 0010 	.+0-W76Name
4413 04151 0051 	W76CFA-W75CFA
4414            W76CFA,
4415 04152 5107 	W4CFA-.		/ (:)
4416            W76PFA,
4417            / State A: Copy the string particulars and start the do loop. Go to
4418            / state B.
4419            W76a,
4420 04153 5762 	W29CFA-.		/ OVER
4421 04154 5761 	W29CFA-.		/ OVER
4422 04155 6377 	W44CFA-.		/ 0
4423 04156 0261 	W49CFA-.		/ (DO)
4424            W760,
4425            / State B: Grap the next character and see if it's a digit. If so,
4426            / go to state C. Otherwise, go to state E.
4427            W76b,
4428 04157 5557 	W20CFA-.		/ DUP
4429 04160 5363 	W13CFA-.		/ B@
4430 04161 7631 	W73CFA-.		/ ISDIGIT
4431 04162 5255 	W10CFA-.		/ (0BRANCH)
4432 04163 0011 	W76e-.
4433            / State C: We have a digit. Bump the character address. If we're
4434            / done, go to staet D. Otherwise, go back to state B.
4435            W76c,
4436 04164 6375 	W21CFA-.		/ 1
4437 04165 6057 	W22CFA-.		/ +
4438 04166 0126 	W50CFA-.		/ (LOOP)
4439 04167 7770 	W760-.
4440            / State D: All characters in the string are digits. Clean the address
4441            / from the stack and stack a 1. Exit.
4442            W76d,
4443 04170 5621 	W24CFA-.		/ DROP
4444 04171 6370 	W21CFA-.		/ 1
4445 04172 5222 	W8CFA-.		/ (BRANCH)
4446 04173 0007 	W76z-.
4447            / State E: At least one character in teh string is not a digit. Clean
4448            / the do loop off the return stack, the address from the math stack,
4449            / and stack a 0. Exit.
4450            W76e,
4451 04174 5661 	W26CFA-.		/ <R
4452 04175 5614 	W24CFA-.		/ DROP
4453 04176 5657 	W26CFA-.		/ <R
4454 04177 5612 	W24CFA-.		/ DROP
4455 04200 5611 	W24CFA-.		/ DROP
4456 04201 6353 	W44CFA-.		/ 0
4457            / *** EXIT ***
4458            W76z,
4459 04202 5105 	W5CFA-.		/ (;)
4460            
4461            
4462            / ----	PROMPT -- word # 77
4463            
4464            W77Name,
4465            
4466            	/ stringengize( PROMPT )
4467 04203 0120 120
4468 04204 0122 122
4469 04205 0117 117
4470 04206 0115 115
4471 04207 0120 120
4472 04210 0124 124
4473            
4474 04211 0006 	.+0-W77Name
4475 04212 0041 	W77CFA-W76CFA
4476            W77CFA,
4477 04213 5253 	W11CFA-.		/ ($)
4478            W77PFA,
4479            /<\r\nOK\r\n>
4480 04214 0006 	W77End-W77Begin
4481            	W77Begin,
4482            
4483            	/ stringengize( \r\nOK\r\n )
4484 04215 0015 15
4485 04216 0012 12
4486 04217 0117 117
4487 04220 0113 113
4488 04221 0015 15
4489 04222 0012 12
4490            
4491            W77End,
4492            / --	INTERPRET - The "outer text interpreter"
4493            / 
4494            / ( -> [varies] )
4495            / 
4496            / This is the user interface for the system. It prompts the user and
4497            / accepts a line of input. The line of input is broken up into
4498            / tokens. Each token is looked up in the dictionary; if it is found,
4499            / the word is executed. If the token is not found, an attempt is made
4500            / to convert the word to a number. If that works, the number is left
4501            / on the stack and the whole shebang starts over.
4502            / 
4503            / Revisions:
4504            / 
4505            / 06/26/96 RLI - State E needs to drop the 0 returned by FIND if the
4506            / 	word is not in the dictionary
4507            / 07/23/96 RLI - Assumed string variables such as prompt execute
4508            / 	as ( -> a c )
4509            
4510            
4511            / ----	INTERPRET -- word # 78
4512            
4513            W78Name,
4514            
4515            	/ stringengize( INTERPRET )
4516 04223 0111 111
4517 04224 0116 116
4518 04225 0124 124
4519 04226 0105 105
4520 04227 0122 122
4521 04230 0120 120
4522 04231 0122 122
4523 04232 0105 105
4524 04233 0124 124
4525            
4526 04234 0011 	.+0-W78Name
4527 04235 0023 	W78CFA-W77CFA
4528            W78CFA,
4529 04236 5023 	W4CFA-.		/ (:)
4530            W78PFA,
4531            / State A: Prompt the user and accept a command line. Go to state B.
4532            W78a,
4533 04237 7754 	W77CFA-.		/ PROMPT
4534 04240 6443 	W52CFA-.		/ TYPE
4535 04241 6710 	W61CFA-.		/ GETLINE
4536            / State B: Get the next token. If there are no tokens left on the
4537            / line, go to state H. Otherwise, go to state C.
4538            W78b,
4539 04242 7171 	W65CFA-.		/ TOKEN
4540 04243 5473 	W20CFA-.		/ DUP
4541 04244 5173 	W10CFA-.		/ (0BRANCH)
4542 04245 0032 	W78h-.
4543            / State C: We have a token. Look it up in the dictionary. If the 
4544            / lookup succeeded, go to state D. Otherwise, go to state E.
4545            W78c,
4546 04246 7451 	W71CFA-.		/ FIND
4547 04247 5467 	W20CFA-.		/ DUP
4548 04250 5167 	W10CFA-.		/ (0BRANCH)
4549 04251 0010 	W78e-.
4550            / State D: There is a word by this name in the dictionary. Strip the
4551            / token info from  the stack (we don't need it anymore since we've
4552            / just figured out what to do about the token) and execute the word.
4553            / Go back to state B.
4554            W78d,
4555 04252 5506 	W23CFA-.		/ SWAP
4556 04253 5536 	W24CFA-.		/ DROP
4557 04254 5504 	W23CFA-.		/ SWAP
4558 04255 5534 	W24CFA-.		/ DROP
4559 04256 4763 	W3CFA-.		/ EXEC
4560 04257 5135 	W8CFA-.		/ (BRANCH)
4561 04260 7762 	W78b-.
4562            / State E: There is no word by this name in the dictionary. Is the
4563            / word a number? If so, go to state F. Otherwise, go to state G.
4564            W78e,
4565 04261 5530 	W24CFA-.		/ DROP
4566 04262 7670 	W76CFA-.		/ ISNUMBER
4567 04263 5154 	W10CFA-.		/ (0BRANCH)
4568 04264 0004 	W78g-.
4569            / State F: The word is a number. Convert it to a number and go to 
4570            / state B.
4571            W78f,
4572 04265 7614 	W75CFA-.		/ >NYBBLES
4573 04266 5126 	W8CFA-.		/ (BRANCH)
4574 04267 7753 	W78b-.
4575            / State G: The word is neither in the dictionary nor a number. It must
4576            / be an error. Yell at the user and go back to state A.
4577            W78g,
4578 04270 6503 	W58CFA-.		/ NL
4579 04271 6412 	W52CFA-.		/ TYPE
4580 04272 6236 	W40CFA-.		/ (LIT)
4581 04273 0077 	77		/ 63
4582 04274 1703 	W47CFA-.		/ EMIT
4583 04275 5117 	W8CFA-.		/ (BRANCH)
4584 04276 7741 	W78a-.
4585            / State H: We've found the end of the line. Drop the null token from
4586            / the stack and go back to state A.
4587            W78h,
4588 04277 5512 	W24CFA-.		/ DROP
4589 04300 5511 	W24CFA-.		/ DROP
4590 04301 5113 	W8CFA-.		/ (BRANCH)
4591 04302 7735 	W78a-.
4592            / This routine doesn't exit, but we need a ; to tell QDL to leave
4593            / compile mode.
4594 04303 5004 	W5CFA-.		/ (;)
4595            / ----
4596            / 
4597            / DO loop primitives
4598            / 
4599            / These words deal with executing a DO ... LOOP construct. They are
4600            / required by other words in the vocabulary as well.
4601            / 
4602            / ----
4603            
4604            
4605            / ----	(LOOP) -- word # 50
4606            
4607            W50Name,
4608            
4609            	/ stringengize( (LOOP) )
4610 04304 0050 50
4611 04305 0114 114
4612 04306 0117 117
4613 04307 0117 117
4614 04310 0120 120
4615 04311 0051 51
4616            
4617 04312 0006 	.+0-W50Name
4618 04313 0056 	W50CFA-W78CFA
4619            W50CFA,
4620 04314 0000 	W50CFA-.		/ (LOOP)
4621            W50PFA,
4622            / (LOOP) - Add one to the index of a do loop.
4623            / 
4624            / M: ( -> )
4625            / R: ( limit, index -> limit, index+1 ) if loop loops
4626            /    ( limit, index -> ) if loop exits
4627            / 
4628            / Assumes the return stack contains:
4629            /  (sp) = index
4630            / 4(sp) = limit
4631            / 
4632            / This procedure adds one to the loop index and then decides whether
4633            / the loop should be repeated or aborted. The loop is repeated if
4634            / the incremented index is less than the limit.
4635            / 
4636            / The reference to (LOOP) is followed by a cell containing the relative
4637            / offset to the top of the loop.
4638            / 
4639            / This code references a label in (BRANCH) called pBranch.
4640            / 
4641            / Revisions:
4642            / 07/30/99 RLI - code version
4643            / Update the index.
4644 04315 4454 	JMS I StupidFetchRP0		/ RP@
4645 04316 4435 	JMS I StupidFetch0		/ @
4646 04317 4461 	JMS I StupidLiteral1		/ 1
4647 04320 0001 	1
4648 04321 4471 	JMS I StupidPlus1			/ +
4649 04322 4455 	JMS I StupidFetchRP1		/ RP@
4650 04323 4475 	JMS I StupidStore1		/ !
4651            / Fetch the limit and index
4652 04324 4454 	JMS I StupidFetchRP0		/ RP@
4653 04325 4435 	JMS I StupidFetch0		/ @
4654 04326 4461 	JMS I StupidLiteral1		/ 1
4655 04327 0001 	1
4656 04330 4456 	JMS I StupidFetchRP2		/ RP@
4657 04331 4472 	JMS I StupidPlus2			/ +
4658 04332 4436 	JMS I StupidFetch1		/ @
4659            / If the index is less than the limit, go to pBranch.
4660 04333 4457 	JMS I StupidLessGo1		/ <GO pBranch
4661 04334 1415 	SL9
4662            / The loop is exiting. We need to pop two cells (the limit and index)
4663            / from the return stack.
4664 04335 4460 	JMS I StupidLiteral0		/ 1
4665 04336 0001 	1
4666 04337 4433 	JMS I StupidDup1			/ DUP
4667 04340 4471 	JMS I StupidPlus1			/ +
4668 04341 4455 	JMS I StupidFetchRP1		/ RP@
4669 04342 4471 	JMS I StupidPlus1			/ +
4670 04343 4504 	JMS I StupidStoreRP0		/ RP!
4671            / We also have to skip the offset to the top of the loop, which 
4672            / immediately follows the reference to (LOOP) in the FORTH code.
4673            / To do this, we bump IP by a cell.
4674 04344 4441 	JMS I StupidFetchIP0		/ IP@
4675 04345 4461 	JMS I StupidLiteral1		/ 1
4676 04346 0001 	1
4677 04347 4471 	JMS I StupidPlus1			/ +
4678 04350 4500 	JMS I StupidStoreIP0		/ IP!
4679 04351 4453 	JMS I StupidFetchNEXT0		/ NEXT@
4680 04352 4503 	JMS I StupidStorePC0		/ PC!
4681            
4682            
4683            / ----	(+LOOP) -- word # 79
4684            
4685            W79Name,
4686            
4687            	/ stringengize( (+LOOP) )
4688 04353 0050 50
4689 04354 0053 53
4690 04355 0114 114
4691 04356 0117 117
4692 04357 0117 117
4693 04360 0120 120
4694 04361 0051 51
4695            
4696 04362 0007 	.+0-W79Name
4697 04363 0050 	W79CFA-W50CFA
4698            W79CFA,
4699 04364 0000 	W79CFA-.		/ (+LOOP)
4700            W79PFA,
4701            / (+LOOP) - Add a specified amount to the index of a do loop.
4702            / 
4703            / M: ( update -> )
4704            / R: ( limit, index -> limit, index + update ) if the loop loops
4705            / R: ( limit, index -> ) if the loop exits
4706            / 
4707            / Assumes the return stack contains:
4708            /  (sp) = index
4709            / 4(sp) = limit
4710            / 
4711            / This procedure adds the value on top of the math stack to the loop
4712            / index and then does the rest of (LOOP); it's like (LOOP) except you
4713            / can specify an increment other than one.
4714            / 
4715            / The increment is discarded from the math stack.
4716            / 
4717            / Like (LOOP), (+LOOP) is followed by a cell  containing the relative
4718            / offset to the top of the loop. Also like (LOOP), the branch is
4719            / performed by entering (BRANCH) at pBranch.
4720            / 
4721            / Revisions:
4722            / 07/30/99 RLI - code version.
4723            / Update the index, which is on the top of the return stack.
4724 04365 4454 	JMS I StupidFetchRP0		/ RP@
4725 04366 4435 	JMS I StupidFetch0		/ @
4726 04367 4450 	JMS I StupidFetchMP1		/ MP@
4727 04370 4436 	JMS I StupidFetch1		/ @
4728 04371 4471 	JMS I StupidPlus1			/ +
4729 04372 4455 	JMS I StupidFetchRP1		/ RP@
4730 04373 4475 	JMS I StupidStore1		/ !
4731            / Drop the update value from the math stack.
4732 04374 4460 	JMS I StupidLiteral0		/ 1
4733 04375 0001 	1
4734 04376 4450 	JMS I StupidFetchMP1		/ MP@
4735 04377 4505 	JMS I StupidSwap1		/ SWAP
4736 04400 4463 	JMS I StupidMinus1		/ -
4737 04401 4501 	JMS I StupidStoreMP0		/ MP!
4738            / If the index is still less than the limit, branch to the top of
4739            / the loop.
4740 04402 4454 	JMS I StupidFetchRP0		/ RP@
4741 04403 4435 	JMS I StupidFetch0		/ @
4742 04404 4461 	JMS I StupidLiteral1		/ 1
4743 04405 0001 	1
4744 04406 4456 	JMS I StupidFetchRP2		/ RP@
4745 04407 4472 	JMS I StupidPlus2			/ +
4746 04410 4436 	JMS I StupidFetch1		/ @
4747 04411 4457 	JMS I StupidLessGo1		/ <GO pBranch
4748 04412 1415 	SL9
4749            / Otherwise, we need to exit the loop. Pop the limit and the index
4750            / from the return stack.
4751 04413 4460 	JMS I StupidLiteral0		/ 1
4752 04414 0001 	1
4753 04415 4433 	JMS I StupidDup1			/ DUP
4754 04416 4471 	JMS I StupidPlus1			/ +
4755 04417 4455 	JMS I StupidFetchRP1		/ RP@
4756 04420 4471 	JMS I StupidPlus1			/ +
4757 04421 4504 	JMS I StupidStoreRP0		/ RP!
4758            / We also need to skip the branch offset, which we are not using this
4759            / time.
4760 04422 4441 	JMS I StupidFetchIP0		/ IP@
4761 04423 4461 	JMS I StupidLiteral1		/ 1
4762 04424 0001 	1
4763 04425 4471 	JMS I StupidPlus1			/ +
4764 04426 4500 	JMS I StupidStoreIP0		/ IP!
4765 04427 4453 	JMS I StupidFetchNEXT0		/ NEXT@
4766 04430 4503 	JMS I StupidStorePC0		/ PC!
4767            / --	(DO) - Initialize a do loop
4768            / 
4769            / ( limit initial -- [pushed to return stack )
4770            / 
4771            / This procedure is the run-time initialization of a do loop; it takes
4772            / the limit and initial value from the math stack and pushes them on
4773            / the return stack in the order required by (LOOP) and (+LOOP).
4774            / 
4775            / Revisions:
4776            / 
4777            / 06/24/96 RLI - Oops! Before I can push things on the return stack,
4778            / 	I need to make certain I understand what I'm doing with
4779            / 	the return address! Sigh.
4780            
4781            
4782            / ----	(DO) -- word # 49
4783            
4784            W49Name,
4785            
4786            	/ stringengize( (DO) )
4787 04431 0050 50
4788 04432 0104 104
4789 04433 0117 117
4790 04434 0051 51
4791            
4792 04435 0004 	.+0-W49Name
4793 04436 0053 	W49CFA-W79CFA
4794            W49CFA,
4795 04437 4622 	W4CFA-.		/ (:)
4796            W49PFA,
4797 04440 5320 	W23CFA-.		/ SWAP
4798 04441 5414 	W26CFA-.		/ <R
4799 04442 5316 	W23CFA-.		/ SWAP
4800 04443 5363 	W25CFA-.		/ >R
4801 04444 5314 	W23CFA-.		/ SWAP
4802 04445 5361 	W25CFA-.		/ >R
4803 04446 5360 	W25CFA-.		/ >R
4804 04447 4640 	W5CFA-.		/ (;)
4805            / --	(DP@) - Fetch the initial value for the dictionary pointer
4806            / 
4807            / M: ( -> InitialDP )
4808            / R: ( -> )
4809            / 
4810            / Revisions:
4811            
4812            
4813            / ----	(DP@) -- word # 80
4814            
4815            W80Name,
4816            
4817            	/ stringengize( (DP@) )
4818 04450 0050 50
4819 04451 0104 104
4820 04452 0120 120
4821 04453 0100 100
4822 04454 0051 51
4823            
4824 04455 0005 	.+0-W80Name
4825 04456 0020 	W80CFA-W49CFA
4826            W80CFA,
4827 04457 0000 	W80CFA-.		/ (DP@)
4828            W80PFA,
4829            / Make space on the math stack for InitialDP
4830 04460 4460 	JMS I StupidLiteral0		/ 1
4831 04461 0001 	1
4832 04462 4450 	JMS I StupidFetchMP1		/ MP@
4833 04463 4471 	JMS I StupidPlus1			/ +
4834 04464 4501 	JMS I StupidStoreMP0		/ MP!
4835            / Copy InitialDP into the space on the math stack
4836 04465 4443 	JMS I StupidFetchInitialDP0		/ InitialDP@
4837 04466 4450 	JMS I StupidFetchMP1		/ MP@
4838 04467 4475 	JMS I StupidStore1		/ !
4839 04470 4453 	JMS I StupidFetchNEXT0		/ NEXT@
4840 04471 4503 	JMS I StupidStorePC0		/ PC!
4841            / --	(LAST@) - Fetch the initial value for LAST
4842            / 
4843            / M: ( -> InitialLAST )
4844            / R: ( -> )
4845            / 
4846            / Revisions:
4847            
4848            
4849            / ----	(LAST@) -- word # 81
4850            
4851            W81Name,
4852            
4853            	/ stringengize( (LAST@) )
4854 04472 0050 50
4855 04473 0114 114
4856 04474 0101 101
4857 04475 0123 123
4858 04476 0124 124
4859 04477 0100 100
4860 04500 0051 51
4861            
4862 04501 0007 	.+0-W81Name
4863 04502 0024 	W81CFA-W80CFA
4864            W81CFA,
4865 04503 0000 	W81CFA-.		/ (LAST@)
4866            W81PFA,
4867            / Make space on the math stack for InitialLAST
4868 04504 4460 	JMS I StupidLiteral0		/ 1
4869 04505 0001 	1
4870 04506 4450 	JMS I StupidFetchMP1		/ MP@
4871 04507 4471 	JMS I StupidPlus1			/ +
4872 04510 4501 	JMS I StupidStoreMP0		/ MP!
4873            / Copy InitialLAST into the space on the math stack
4874 04511 4444 	JMS I StupidFetchInitialLAST0		/ InitialLAST@
4875 04512 4450 	JMS I StupidFetchMP1		/ MP@
4876 04513 4475 	JMS I StupidStore1		/ !
4877 04514 4453 	JMS I StupidFetchNEXT0		/ NEXT@
4878 04515 4503 	JMS I StupidStorePC0		/ PC!
4879            / --	Messages to be displayed by IDENTIFY
4880            
4881            
4882            / ----	IDMSG1 -- word # 82
4883            
4884            W82Name,
4885            
4886            	/ stringengize( IDMSG1 )
4887 04516 0111 111
4888 04517 0104 104
4889 04520 0115 115
4890 04521 0123 123
4891 04522 0107 107
4892 04523 0061 61
4893            
4894 04524 0006 	.+0-W82Name
4895 04525 0023 	W82CFA-W81CFA
4896            W82CFA,
4897 04526 4740 	W11CFA-.		/ ($)
4898            W82PFA,
4899            /<THIRD V0.0 CellSize >
4900 04527 0024 	W82End-W82Begin
4901            	W82Begin,
4902            
4903            	/ stringengize( THIRD V0.0 CellSize  )
4904 04530 0124 124
4905 04531 0110 110
4906 04532 0111 111
4907 04533 0122 122
4908 04534 0104 104
4909 04535 0040 40
4910 04536 0126 126
4911 04537 0060 60
4912 04540 0056 56
4913 04541 0060 60
4914 04542 0040 40
4915 04543 0103 103
4916 04544 0145 145
4917 04545 0154 154
4918 04546 0154 154
4919 04547 0123 123
4920 04550 0151 151
4921 04551 0172 172
4922 04552 0145 145
4923 04553 0040 40
4924            
4925            W82End,
4926            
4927            
4928            / ----	IDMSG2 -- word # 83
4929            
4930            W83Name,
4931            
4932            	/ stringengize( IDMSG2 )
4933 04554 0111 111
4934 04555 0104 104
4935 04556 0115 115
4936 04557 0123 123
4937 04560 0107 107
4938 04561 0062 62
4939            
4940 04562 0006 	.+0-W83Name
4941 04563 0036 	W83CFA-W82CFA
4942            W83CFA,
4943 04564 4702 	W11CFA-.		/ ($)
4944            W83PFA,
4945            /<WordSize >
4946 04565 0011 	W83End-W83Begin
4947            	W83Begin,
4948            
4949            	/ stringengize( WordSize  )
4950 04566 0127 127
4951 04567 0157 157
4952 04570 0162 162
4953 04571 0144 144
4954 04572 0123 123
4955 04573 0151 151
4956 04574 0172 172
4957 04575 0145 145
4958 04576 0040 40
4959            
4960            W83End,
4961            
4962            
4963            / ----	IDMSG3 -- word # 84
4964            
4965            W84Name,
4966            
4967            	/ stringengize( IDMSG3 )
4968 04577 0111 111
4969 04600 0104 104
4970 04601 0115 115
4971 04602 0123 123
4972 04603 0107 107
4973 04604 0063 63
4974            
4975 04605 0006 	.+0-W84Name
4976 04606 0023 	W84CFA-W83CFA
4977            W84CFA,
4978 04607 4657 	W11CFA-.		/ ($)
4979            W84PFA,
4980            /<Bits >
4981 04610 0005 	W84End-W84Begin
4982            	W84Begin,
4983            
4984            	/ stringengize( Bits  )
4985 04611 0102 102
4986 04612 0151 151
4987 04613 0164 164
4988 04614 0163 163
4989 04615 0040 40
4990            
4991            W84End,
4992            / --	IDENTIFY - Display info about this system
4993            / 
4994            / 	( -- )
4995            / 
4996            / Revisions:
4997            
4998            
4999            / ----	IDENTIFY -- word # 85
5000            
5001            W85Name,
5002            
5003            	/ stringengize( IDENTIFY )
5004 04616 0111 111
5005 04617 0104 104
5006 04620 0105 105
5007 04621 0116 116
5008 04622 0124 124
5009 04623 0111 111
5010 04624 0106 106
5011 04625 0131 131
5012            
5013 04626 0010 	.+0-W85Name
5014 04627 0021 	W85CFA-W84CFA
5015            W85CFA,
5016 04630 4431 	W4CFA-.		/ (:)
5017            W85PFA,
5018 04631 7675 	W82CFA-.		/ IDMSG1
5019 04632 6051 	W52CFA-.		/ TYPE
5020 04633 5675 	W40CFA-.		/ (LIT)
5021 04634 0001 	1		/ 1
5022 04635 6030 	W51CFA-.		/ .
5023 04636 7726 	W83CFA-.		/ IDMSG2
5024 04637 6044 	W52CFA-.		/ TYPE
5025 04640 5670 	W40CFA-.		/ (LIT)
5026 04641 0001 	1		/ 1
5027 04642 6023 	W51CFA-.		/ .
5028 04643 7744 	W84CFA-.		/ IDMSG3
5029 04644 6037 	W52CFA-.		/ TYPE
5030 04645 5663 	W40CFA-.		/ (LIT)
5031 04646 0014 	14		/ 12
5032 04647 6016 	W51CFA-.		/ .
5033 04650 6123 	W58CFA-.		/ NL
5034 04651 4436 	W5CFA-.		/ (;)
5035            / --	(COLD) - Perform final power-on initialization
5036            / 
5037            / 	This word performs initialization that should be done once at
5038            / power-on. It is assumed that the low-level initialization code
5039            / has initialized the UART and the various low-level registers
5040            / (NEXT, InitialRP, InitialMP, etc.) needed by the system. This
5041            / word initializes the math and return stacks, identifies the
5042            / system, and then does an ABORT.
5043            / 
5044            / Revisions:
5045            
5046            
5047            / ----	(COLD) -- word # 1000
5048            
5049            W1000Name,
5050            
5051            	/ stringengize( (COLD) )
5052 04652 0050 50
5053 04653 0103 103
5054 04654 0117 117
5055 04655 0114 114
5056 04656 0104 104
5057 04657 0051 51
5058            
5059 04660 0006 	.+0-W1000Name
5060 04661 0032 	W1000CFA-W85CFA
5061            W1000CFA,
5062 04662 4377 	W4CFA-.		/ (:)
5063            W1000PFA,
5064 04663 5265 	W30CFA-.		/ MP!
5065 04664 5236 	W28CFA-.		/ RP!
5066 04665 7572 	W80CFA-.		/ (DP@)
5067 04666 0030 	W86CFA-.		/ DP
5068 04667 4722 	W16CFA-.		/ !
5069 04670 7613 	W81CFA-.		/ (LAST@)
5070 04671 6675 	W67CFA-.		/ LAST
5071 04672 4717 	W16CFA-.		/ !
5072 04673 7735 	W85CFA-.		/ IDENTIFY
5073 04674 0011 	W56CFA-.		/ ABORT
5074 04675 4412 	W5CFA-.		/ (;)
5075            / -----
5076            / 
5077            / ABORT
5078            / 
5079            / -----
5080            
5081            
5082            / ----	ABORT -- word # 56
5083            
5084            W56Name,
5085            
5086            	/ stringengize( ABORT )
5087 04676 0101 101
5088 04677 0102 102
5089 04700 0117 117
5090 04701 0122 122
5091 04702 0124 124
5092            
5093 04703 0005 	.+0-W56Name
5094 04704 0023 	W56CFA-W1000CFA
5095            W56CFA,
5096 04705 4354 	W4CFA-.		/ (:)
5097            W56PFA,
5098 04706 5242 	W30CFA-.		/ MP!
5099 04707 5213 	W28CFA-.		/ RP!
5100 04710 7326 	W78CFA-.		/ INTERPRET
5101 04711 4376 	W5CFA-.		/ (;)
5102            / ----
5103            / 
5104            / Dictionary manipulation primitives
5105            / 
5106            / These words do the very basic work of adding things to the
5107            / dictionary.
5108            / 
5109            / Revisions:	04/21/97 RLI - Changed flag byte to be a flag longword.
5110            / 
5111            / 		05/11/01 RLI - Fixed bogus blank line comments.
5112            / 
5113            / ----
5114            
5115            
5116            / ----	DP -- word # 86
5117            
5118            W86Name,
5119            
5120            	/ stringengize( DP )
5121 04712 0104 104
5122 04713 0120 120
5123            
5124 04714 0002 	.+0-W86Name
5125 04715 0011 	W86CFA-W56CFA
5126            W86CFA,
5127 04716 4446 	W7CFA-.		/ (VAR)
5128            W86PFA,
5129 04717 0000 	0
5130            
5131            
5132            / ----	(OLIT) -- word # 87
5133            
5134            W87Name,
5135            
5136            	/ stringengize( (OLIT) )
5137 04720 0050 50
5138 04721 0117 117
5139 04722 0114 114
5140 04723 0111 111
5141 04724 0124 124
5142 04725 0051 51
5143            
5144 04726 0006 	.+0-W87Name
5145 04727 0012 	W87CFA-W86CFA
5146            W87CFA,
5147 04730 0000 	W87CFA-.		/ (OLIT)
5148            W87PFA,
5149            / (OLIT) - Extend and relocate a relative literal
5150            / 
5151            / M: ( -> literal )
5152            / R: ( -> )
5153            / 
5154            / This word is used to create references to words in the code which, at
5155            / execution, will result in the address of the word being pushed on the
5156            / stack.
5157            / 
5158            / The reference to (OLIT) is followed by a relative offset that is
5159            / relocated into the target address referenced by the offset and
5160            / pushed on the stack.
5161            / 
5162            / Revisions:
5163            / 07/29/99 RLI - code version
5164            / Make space on the math stack for the literal
5165 04731 4460 	JMS I StupidLiteral0		/ 1
5166 04732 0001 	1
5167 04733 4450 	JMS I StupidFetchMP1		/ MP@
5168 04734 4471 	JMS I StupidPlus1			/ +
5169 04735 4501 	JMS I StupidStoreMP0		/ MP!
5170            / Fetch the offset and relocate it.
5171 04736 4441 	JMS I StupidFetchIP0		/ IP@
5172 04737 4435 	JMS I StupidFetch0		/ @
5173 04740 4442 	JMS I StupidFetchIP1		/ IP@
5174 04741 4471 	JMS I StupidPlus1			/ +
5175            / Store the offset on the math stack
5176 04742 4450 	JMS I StupidFetchMP1		/ MP@
5177 04743 4475 	JMS I StupidStore1		/ !
5178            / Advance IP over the literal and continue on.
5179 04744 4441 	JMS I StupidFetchIP0		/ IP@
5180 04745 4461 	JMS I StupidLiteral1		/ 1
5181 04746 0001 	1
5182 04747 4471 	JMS I StupidPlus1			/ +
5183 04750 4500 	JMS I StupidStoreIP0		/ IP!
5184 04751 4453 	JMS I StupidFetchNEXT0		/ NEXT@
5185 04752 4503 	JMS I StupidStorePC0		/ PC!
5186            / --	O@ - Fetch the value of a relative offset
5187            / 
5188            / ( a -> b )
5189            / 
5190            / The word address by 'a' is fetched, sign-extended, and added
5191            / to 'a'. This converts the word addressed by 'a' to the absolute
5192            / address 'b'.
5193            / 
5194            / Revisions:
5195            / 
5196            / 06/28/96 RLI - Modified to use cell-sized offset.
5197            
5198            
5199            / ----	O@ -- word # 88
5200            
5201            W88Name,
5202            
5203            	/ stringengize( O@ )
5204 04753 0117 117
5205 04754 0100 100
5206            
5207 04755 0002 	.+0-W88Name
5208 04756 0027 	W88CFA-W87CFA
5209            W88CFA,
5210 04757 4302 	W4CFA-.		/ (:)
5211            W88PFA,
5212 04760 4756 	W20CFA-.		/ DUP
5213 04761 4546 	W12CFA-.		/ @
5214 04762 5262 	W22CFA-.		/ +
5215 04763 4324 	W5CFA-.		/ (;)
5216            / --	O! - Store a relative offset
5217            / 
5218            / 	( target address -> )
5219            / 
5220            / This word stores a 16-bit relative offset from address to target
5221            / at address.
5222            / 
5223            / Revisions:
5224            / 
5225            / 06/28/96 RLI - Modified to use cell-size offset.
5226            
5227            
5228            / ----	O! -- word # 89
5229            
5230            W89Name,
5231            
5232            	/ stringengize( O! )
5233 04764 0117 117
5234 04765 0041 41
5235            
5236 04766 0002 	.+0-W89Name
5237 04767 0011 	W89CFA-W88CFA
5238            W89CFA,
5239 04770 4271 	W4CFA-.		/ (:)
5240            W89PFA,
5241 04771 4767 	W23CFA-.		/ SWAP
5242 04772 5143 	W29CFA-.		/ OVER
5243 04773 5205 	W32CFA-.		/ -
5244 04774 4764 	W23CFA-.		/ SWAP
5245 04775 4614 	W16CFA-.		/ !
5246 04776 4311 	W5CFA-.		/ (;)
5247            / --	B, - Append a byte to the dictionary
5248            / 
5249            / ( a -> )
5250            / 
5251            / a is stored in the first unused byte after the dictionary and
5252            / the dictionary pointer is advanced to the next byte; this makes
5253            / a the last byte in the dictionary.
5254            
5255            
5256            / ----	B, -- word # 90
5257            
5258            W90Name,
5259            
5260            	/ stringengize( B, )
5261 04777 0102 102
5262 05000 0054 54
5263            
5264 05001 0002 	.+0-W90Name
5265 05002 0013 	W90CFA-W89CFA
5266            W90CFA,
5267 05003 4256 	W4CFA-.		/ (:)
5268            W90PFA,
5269 05004 7712 	W86CFA-.		/ DP
5270 05005 4522 	W12CFA-.		/ @
5271 05006 4633 	W17CFA-.		/ B!
5272 05007 7707 	W86CFA-.		/ DP
5273 05010 4711 	W19CFA-.		/ ++
5274 05011 4276 	W5CFA-.		/ (;)
5275            / --	W, - Append a word to the dictionary
5276            / 
5277            / ( a -> )
5278            / 
5279            / a is stored in the first unused word after the dictionary and
5280            / the dictionary pointer is advanced to the next word; this makes
5281            / a the last word in the dictionary.
5282            
5283            
5284            / ----	W, -- word # 91
5285            
5286            W91Name,
5287            
5288            	/ stringengize( W, )
5289 05012 0127 127
5290 05013 0054 54
5291            
5292 05014 0002 	.+0-W91Name
5293 05015 0013 	W91CFA-W90CFA
5294            W91CFA,
5295 05016 4243 	W4CFA-.		/ (:)
5296            W91PFA,
5297 05017 7677 	W86CFA-.		/ DP
5298 05020 4507 	W12CFA-.		/ @
5299 05021 4650 	W18CFA-.		/ W!
5300 05022 7674 	W86CFA-.		/ DP
5301 05023 4504 	W12CFA-.		/ @
5302 05024 5504 	W40CFA-.		/ (LIT)
5303 05025 0001 	1		/ 1
5304 05026 5216 	W22CFA-.		/ +
5305 05027 7667 	W86CFA-.		/ DP
5306 05030 4561 	W16CFA-.		/ !
5307 05031 4256 	W5CFA-.		/ (;)
5308            / --	, - Append a longword to the dictionary
5309            / 
5310            / ( a -> )
5311            / 
5312            / a is stored in the first longword after the dictionary and
5313            / the dictionary pointer is advanced to the next longword; this makes
5314            / a the last longword in the dictionary
5315            
5316            
5317            / ----	, -- word # 92
5318            
5319            W92Name,
5320            
5321            	/ stringengize( , )
5322 05032 0054 54
5323            
5324 05033 0001 	.+0-W92Name
5325 05034 0017 	W92CFA-W91CFA
5326            W92CFA,
5327 05035 4224 	W4CFA-.		/ (:)
5328            W92PFA,
5329 05036 7660 	W86CFA-.		/ DP
5330 05037 4470 	W12CFA-.		/ @
5331 05040 4551 	W16CFA-.		/ !
5332 05041 7655 	W86CFA-.		/ DP
5333 05042 4465 	W12CFA-.		/ @
5334 05043 5465 	W40CFA-.		/ (LIT)
5335 05044 0001 	1		/ 1
5336 05045 5177 	W22CFA-.		/ +
5337 05046 7650 	W86CFA-.		/ DP
5338 05047 4542 	W16CFA-.		/ !
5339 05050 4237 	W5CFA-.		/ (;)
5340            / --	O, - Append a relative offset to the dictionary
5341            / 
5342            / 	( a -> )
5343            / 
5344            / The difference between the end of the dictionary and a is stored
5345            / in the first unused longword after the dictionary. The dictionary
5346            / pointer is advanced past this longword, making a-DP the last
5347            / longword in the dictionary.
5348            
5349            
5350            / ----	O, -- word # 93
5351            
5352            W93Name,
5353            
5354            	/ stringengize( O, )
5355 05051 0117 117
5356 05052 0054 54
5357            
5358 05053 0002 	.+0-W93Name
5359 05054 0020 	W93CFA-W92CFA
5360            W93CFA,
5361 05055 4204 	W4CFA-.		/ (:)
5362            W93PFA,
5363 05056 7640 	W86CFA-.		/ DP
5364 05057 4450 	W12CFA-.		/ @
5365 05060 5120 	W32CFA-.		/ -
5366 05061 7754 	W92CFA-.		/ ,
5367 05062 4225 	W5CFA-.		/ (;)
5368            / --	$, - Append a counted string to the dictionary
5369            / 
5370            / ( addr count -> )
5371            / 
5372            / This word appends a counted string to the dictionary. Each byte
5373            / of the string is appended to the dictionary using B,. After the
5374            / string is copied, it is padded with nulls until the name ends on an
5375            / even longword boundary. At that even longword boundary, the length byte
5376            / for the name is appended; the rest of the word header consists of one byte
5377            / for the link and a word for the CFA, so when the header is complete the
5378            / definition of the word will be longword aligned.
5379            / 
5380            / NOTE: The caller is responsible for ensuring the string is not longer
5381            / than 63 characters.
5382            / 
5383            / Revisions:
5384            / 
5385            / 07/08/96 RLI - The flags byte now requires a longword so that
5386            / 	code remains longword aligned with longword offsets.
5387            
5388            
5389            / ----	$, -- word # 94
5390            
5391            W94Name,
5392            
5393            	/ stringengize( $, )
5394 05063 0044 44
5395 05064 0054 54
5396            
5397 05065 0002 	.+0-W94Name
5398 05066 0012 	W94CFA-W93CFA
5399            W94CFA,
5400 05067 4172 	W4CFA-.		/ (:)
5401            W94PFA,
5402            / *** ENTRY ***
5403            / 
5404            / M: Address of string, length of string
5405            / R: Return address
5406            / State A: Start up a do loop for the length of the string. Fetch the
5407            / directory pointer so that we can use it at the end to calculate the
5408            / length of the name. Go to state B.
5409            /  
5410            / M: Original DP, address of string
5411            / R: REturn address, lmit, index
5412            W94a,
5413 05070 4736 	W25CFA-.		/ >R
5414 05071 7625 	W86CFA-.		/ DP
5415 05072 4435 	W12CFA-.		/ @
5416 05073 4665 	W23CFA-.		/ SWAP
5417 05074 4761 	W26CFA-.		/ <R
5418 05075 5433 	W40CFA-.		/ (LIT)
5419 05076 0000 	0		/ 0
5420 05077 7340 	W49CFA-.		/ (DO)
5421            W940,
5422            / State B: Append the next byte from the string to the dictionary and
5423            / bump the pointer into the string. Loop until done.
5424            / 
5425            / M: Original DP, Address of byte after the end of the string
5426            / R: Return address
5427            W94b,
5428 05100 4636 	W20CFA-.		/ DUP
5429 05101 4442 	W13CFA-.		/ B@
5430 05102 7701 	W90CFA-.		/ B,
5431 05103 5456 	W21CFA-.		/ 1
5432 05104 5140 	W22CFA-.		/ +
5433 05105 7207 	W50CFA-.		/ (LOOP)
5434 05106 7772 	W940-.
5435            / State C: We're done fetching bytes from the string, so drop the pointer
5436            / into the string from the stack. Get the current dictionary pointer so we
5437            / can test to see if it's aligned. Go to state D.
5438            W94c,
5439 05107 4702 	W24CFA-.		/ DROP
5440 05110 7606 	W86CFA-.		/ DP
5441 05111 4416 	W12CFA-.		/ @
5442            / State D: Test the low-order two bits of the dictionary pointer to see if
5443            / we've longword aligned it. If so, go to state F. Otherwise, go to state
5444            / E.
5445            / 
5446            / M: Original DP, Low-order two bits of DP
5447            W94d,
5448 05112 4624 	W20CFA-.		/ DUP
5449 05113 5415 	W40CFA-.		/ (LIT)
5450 05114 0003 	3		/ 3
5451 05115 5160 	W34CFA-.		/ AND
5452 05116 4321 	W10CFA-.		/ (0BRANCH)
5453 05117 0007 	W94f-.
5454            / State E: DP is not yet longword alined. Append a null to the name and
5455            / bump our copy of DP's low-order bits. Go to state D.
5456            / 
5457            / M: Original DP, (Low-order bits of DP) + 1
5458            W94e,
5459 05120 5434 	W44CFA-.		/ 0
5460 05121 7662 	W90CFA-.		/ B,
5461 05122 5437 	W21CFA-.		/ 1
5462 05123 5121 	W22CFA-.		/ +
5463 05124 4270 	W8CFA-.		/ (BRANCH)
5464 05125 7765 	W94d-.
5465            / State F: We've longword aligned the dictionary. Drop the low-order two
5466            / bits of DP since we don't need them anymore. Figure out how long the
5467            / string is and deposit the length byte. Exit.
5468            / 
5469            / M:
5470            W94f,
5471 05126 4663 	W24CFA-.		/ DROP
5472 05127 7567 	W86CFA-.		/ DP
5473 05130 4377 	W12CFA-.		/ @
5474 05131 4627 	W23CFA-.		/ SWAP
5475 05132 5046 	W32CFA-.		/ -
5476 05133 7702 	W92CFA-.		/ ,
5477            / *** EXIT ***
5478            / 
5479            / M:
5480            / R:
5481            W94z,
5482 05134 4153 	W5CFA-.		/ (;)
5483            / --	ALLOT - Allocate a chunk of memory into a word
5484            / 
5485            / ( bytes -> )
5486            / 
5487            / This word allocates a chunk of memory onto the end of the last
5488            / word in the dictionary. It does this by simply advancing the
5489            / dictionary pointer past the memory.
5490            
5491            
5492            / ----	ALLOT -- word # 95
5493            
5494            W95Name,
5495            
5496            	/ stringengize( ALLOT )
5497 05135 0101 101
5498 05136 0114 114
5499 05137 0114 114
5500 05140 0117 117
5501 05141 0124 124
5502            
5503 05142 0005 	.+0-W95Name
5504 05143 0055 	W95CFA-W94CFA
5505            W95CFA,
5506 05144 4115 	W4CFA-.		/ (:)
5507            W95PFA,
5508 05145 7551 	W86CFA-.		/ DP
5509 05146 4361 	W12CFA-.		/ @
5510 05147 5075 	W22CFA-.		/ +
5511 05150 7546 	W86CFA-.		/ DP
5512 05151 4440 	W16CFA-.		/ !
5513 05152 4135 	W5CFA-.		/ (;)
5514            / --	CREATE - Create a new word
5515            / 
5516            / ( -> )
5517            / 
5518            / This word appends the bulk of a header to the dictionary. It creates
5519            / the name, flag, and link bytes and points LAST at the new header.
5520            / When done, DP points at the CFA for the new word; the caller must
5521            / fill in the CFA with a suitable O, before storing the definition of
5522            / the word.
5523            / 
5524            / CREATE obtains the name of the word from the input buffer; it calls
5525            / TOKEN to get the next word from the input buffer. If there are
5526            / no tokens left in the input buffer, CREATE will display an error
5527            / message and ABORT.
5528            / 
5529            / CREATE may also ABORT if the name is longer than 63 characters (the
5530            / longest name that may be supported by the Flags byte).
5531            
5532            
5533            / ----	CREATE -- word # 96
5534            
5535            W96Name,
5536            
5537            	/ stringengize( CREATE )
5538 05153 0103 103
5539 05154 0122 122
5540 05155 0105 105
5541 05156 0101 101
5542 05157 0124 124
5543 05160 0105 105
5544            
5545 05161 0006 	.+0-W96Name
5546 05162 0017 	W96CFA-W95CFA
5547            W96CFA,
5548 05163 4076 	W4CFA-.		/ (:)
5549            W96PFA,
5550            / *** ENTRY ***
5551            / 
5552            / M:
5553            / R: Return address
5554            / State A: Grab the next token from the input buffer. If there is no next
5555            / token (we're at the end of the line), go to state E. Otherwise, go to
5556            / state B.
5557            / 
5558            / M: Address of token, length of token
5559            W96a,
5560 05164 6247 	W65CFA-.		/ TOKEN
5561 05165 4551 	W20CFA-.		/ DUP
5562 05166 4251 	W10CFA-.		/ (0BRANCH)
5563 05167 0023 	W96e-.
5564            / State B: Make certain the name isn't too long. If the name is too
5565            / long, go to state F. Otherwise, go to state C.
5566            / 
5567            / M: Address of token, length of token
5568            W96b,
5569 05170 4546 	W20CFA-.		/ DUP
5570 05171 5337 	W40CFA-.		/ (LIT)
5571 05172 0100 	100		/ 64
5572 05173 5267 	W41CFA-.		/ <
5573 05174 4243 	W10CFA-.		/ (0BRANCH)
5574 05175 0020 	W96f-.
5575            / State C: We have a reasonable token. Toss it on the end of the dictionary.
5576            / Compute and store the link field. Go to state G.
5577            / 
5578            / M:
5579            W96c,
5580 05176 7671 	W94CFA-.		/ $,
5581 05177 7517 	W86CFA-.		/ DP
5582 05200 4327 	W12CFA-.		/ @
5583 05201 5327 	W40CFA-.		/ (LIT)
5584 05202 0001 	1		/ 1
5585 05203 5041 	W22CFA-.		/ +
5586 05204 6362 	W67CFA-.		/ LAST
5587 05205 4322 	W12CFA-.		/ @
5588 05206 4772 	W32CFA-.		/ -
5589 05207 7626 	W92CFA-.		/ ,
5590 05210 4204 	W8CFA-.		/ (BRANCH)
5591 05211 0007 	W96g-.
5592            / State D: (deleted)
5593            / State E: There is no token on the line following the word which decided
5594            / to create a new word. In other words, we don't have a name for the new
5595            / word. Complain and ABORT.
5596            / 
5597            / M: Doesn't matter because we're ABORTing.
5598            W96e,
5599 05212 0022 	W97CFA-.		/ NAME?
5600 05213 5470 	W52CFA-.		/ TYPE
5601 05214 7471 	W56CFA-.		/ ABORT
5602            / State F: The token is too long. Display an error message and ABORT.
5603            / 
5604            / M: Doesn't matter because we're ABORTing.
5605            W96f,
5606 05215 0040 	W98CFA-.		/ LEN?
5607 05216 5465 	W52CFA-.		/ TYPE
5608 05217 7466 	W56CFA-.		/ ABORT
5609            / State G: The header is cool. Update LAST to point at the new header
5610            / and exit.
5611            W96g,
5612 05220 7476 	W86CFA-.		/ DP
5613 05221 4306 	W12CFA-.		/ @
5614 05222 6344 	W67CFA-.		/ LAST
5615 05223 4366 	W16CFA-.		/ !
5616            / **** EXIT ****
5617            / 
5618            / M:
5619            / R:
5620            W96z,
5621 05224 4063 	W5CFA-.		/ (;)
5622            / --	NAME? - This word contains an error message displayed by CREATE
5623            / if there is no name for the new word in the input buffer.
5624            
5625            
5626            / ----	NAME? -- word # 97
5627            
5628            W97Name,
5629            
5630            	/ stringengize( NAME? )
5631 05225 0116 116
5632 05226 0101 101
5633 05227 0115 115
5634 05230 0105 105
5635 05231 0077 77
5636            
5637 05232 0005 	.+0-W97Name
5638 05233 0051 	W97CFA-W96CFA
5639            W97CFA,
5640 05234 4232 	W11CFA-.		/ ($)
5641            W97PFA,
5642            /<\r\nName?\r\n>
5643 05235 0011 	W97End-W97Begin
5644            	W97Begin,
5645            
5646            	/ stringengize( \r\nName?\r\n )
5647 05236 0015 15
5648 05237 0012 12
5649 05240 0116 116
5650 05241 0141 141
5651 05242 0155 155
5652 05243 0145 145
5653 05244 0077 77
5654 05245 0015 15
5655 05246 0012 12
5656            
5657            W97End,
5658            / --	LEN? - This word contains an error message displayed by CREATE
5659            / if the name for the new word is too long.
5660            
5661            
5662            / ----	LEN? -- word # 98
5663            
5664            W98Name,
5665            
5666            	/ stringengize( LEN? )
5667 05247 0114 114
5668 05250 0105 105
5669 05251 0116 116
5670 05252 0077 77
5671            
5672 05253 0004 	.+0-W98Name
5673 05254 0021 	W98CFA-W97CFA
5674            W98CFA,
5675 05255 4211 	W11CFA-.		/ ($)
5676            W98PFA,
5677            /<\r\nLen?\r\n>
5678 05256 0010 	W98End-W98Begin
5679            	W98Begin,
5680            
5681            	/ stringengize( \r\nLen?\r\n )
5682 05257 0015 15
5683 05260 0012 12
5684 05261 0114 114
5685 05262 0145 145
5686 05263 0156 156
5687 05264 0077 77
5688 05265 0015 15
5689 05266 0012 12
5690            
5691            W98End,
5692            / --	VARIABLE - Create a variable
5693            / 
5694            / 	( a -> )
5695            / 
5696            / This word creates a variable with a specified name. The value on
5697            / top of the math stack is stored in the variable after the header
5698            / is created. The name of the variable is taken from the input buffer;
5699            / i.e., it's the word of input following VARIABLE.
5700            
5701            
5702            / ----	VARIABLE -- word # 99
5703            
5704            W99Name,
5705            
5706            	/ stringengize( VARIABLE )
5707 05267 0126 126
5708 05270 0101 101
5709 05271 0122 122
5710 05272 0111 111
5711 05273 0101 101
5712 05274 0102 102
5713 05275 0114 114
5714 05276 0105 105
5715            
5716 05277 0010 	.+0-W99Name
5717 05300 0024 	W99CFA-W98CFA
5718            W99CFA,
5719 05301 3760 	W4CFA-.		/ (:)
5720            W99PFA,
5721            / First, create the header
5722 05302 7661 	W96CFA-.		/ CREATE
5723            / Point the CFA at (VAR)
5724 05303 7425 	W87CFA-.		/ (OLIT)
5725 05304 4060 	W7CFA-.		/ (VAR)
5726 05305 7550 	W93CFA-.		/ O,
5727            / Store the value into the new variable
5728 05306 7527 	W92CFA-.		/ ,
5729 05307 4000 	W5CFA-.		/ (;)
5730            / --	CONSTANT - Create a constant
5731            / 
5732            / 	( a -> )
5733            / 
5734            / This word creates a constant with a specified name. The value on
5735            / top of the math stack is stored in the constant after the header
5736            / is created. The name of the constant is taken from the input buffer;
5737            / i.e., it's the word of input following CONSTANT.
5738            
5739            
5740            / ----	CONSTANT -- word # 100
5741            
5742            W100Name,
5743            
5744            	/ stringengize( CONSTANT )
5745 05310 0103 103
5746 05311 0117 117
5747 05312 0116 116
5748 05313 0123 123
5749 05314 0124 124
5750 05315 0101 101
5751 05316 0116 116
5752 05317 0124 124
5753            
5754 05320 0010 	.+0-W100Name
5755 05321 0021 	W100CFA-W99CFA
5756            W100CFA,
5757 05322 3737 	W4CFA-.		/ (:)
5758            W100PFA,
5759            / First, create the header
5760 05323 7640 	W96CFA-.		/ CREATE
5761            / Point the CFA at (CONSTANT)
5762 05324 7404 	W87CFA-.		/ (OLIT)
5763 05325 4011 	W6CFA-.		/ (CONSTANT)
5764 05326 7527 	W93CFA-.		/ O,
5765            / Store the value into the new variable
5766 05327 7506 	W92CFA-.		/ ,
5767 05330 3757 	W5CFA-.		/ (;)
5768            / --	CODE - Create a machine code word
5769            / 
5770            / ( -> )
5771            / 
5772            / This word creates a word containing machine code. It creates a
5773            / header whose CFA points to the word's definition; i.e., it
5774            / creates a header for which the word itself contains the machine
5775            / code which knows how to execute the word. The code executed by
5776            / the word must be appended to the header using the various ',' words.
5777            / 
5778            / The name of the new word is taken from the input buffer; i.e., it
5779            / follows CODE on the input line.
5780            / 
5781            / Revisions:
5782            / 	08/09/96 RLI - Removed assumption that CFA is a relative offset.
5783            / 08/27/96 RLI - Fixed the 08/09 fix.
5784            
5785            
5786            / ----	CODE -- word # 101
5787            
5788            W101Name,
5789            
5790            	/ stringengize( CODE )
5791 05331 0103 103
5792 05332 0117 117
5793 05333 0104 104
5794 05334 0105 105
5795            
5796 05335 0004 	.+0-W101Name
5797 05336 0015 	W101CFA-W100CFA
5798            W101CFA,
5799 05337 3722 	W4CFA-.		/ (:)
5800            W101PFA,
5801 05340 7623 	W96CFA-.		/ CREATE
5802 05341 7355 	W86CFA-.		/ DP
5803 05342 4165 	W12CFA-.		/ @
5804 05343 7512 	W93CFA-.		/ O,
5805 05344 3743 	W5CFA-.		/ (;)
5806            / --	$ - Compile a string into a word
5807            / 
5808            / ( -> )
5809            / 
5810            / This word compiles a string into a word. The token following $ on
5811            / the input line is used as the name of the word. The rest of the
5812            / input line is copied into the dictionary following the header and
5813            / string length byte.
5814            
5815            
5816            / ----	$ -- word # 102
5817            
5818            W102Name,
5819            
5820            	/ stringengize( $ )
5821 05345 0044 44
5822            
5823 05346 0001 	.+0-W102Name
5824 05347 0011 	W102CFA-W101CFA
5825            W102CFA,
5826 05350 3711 	W4CFA-.		/ (:)
5827            W102PFA,
5828            / Create the word and point its CFA at ($)
5829 05351 7612 	W96CFA-.		/ CREATE
5830 05352 7356 	W87CFA-.		/ (OLIT)
5831 05353 4113 	W11CFA-.		/ ($)
5832 05354 7501 	W93CFA-.		/ O,
5833            / Calculate the length of the remaining line. This is given by 
5834            / searching for the null terminating the input buffer.
5835 05355 5433 	W59CFA-.		/ INBUF
5836 05356 5560 	W60CFA-.		/ IN
5837 05357 4150 	W12CFA-.		/ @
5838 05360 4664 	W22CFA-.		/ +
5839 05361 5173 	W44CFA-.		/ 0
5840            / Examine the character. If it's a null, we're done. Otherwise,
5841            / we need to bump the address and look at the next character.
5842            W102a,
5843 05362 6026 	W64CFA-.		/ NEXTCHAR
5844 05363 4054 	W10CFA-.		/ (0BRANCH)
5845 05364 0005 	W102b-.
5846            / The character is not null. Count it and repeat.
5847 05365 5174 	W21CFA-.		/ 1
5848 05366 4656 	W22CFA-.		/ +
5849 05367 4025 	W8CFA-.		/ (BRANCH)
5850 05370 7772 	W102a-.
5851            / The character is a null; we've found the string length. Append
5852            / the string length to the dictionary followed by the string.
5853            W102b,
5854 05371 4345 	W20CFA-.		/ DUP
5855 05372 7411 	W90CFA-.		/ B,
5856 05373 7474 	W94CFA-.		/ $,
5857            / Note that we'll have a couple of extra bytes at the end (padding
5858            / to longword boundary followed by a flag byte, but that's OK.
5859 05374 3713 	W5CFA-.		/ (;)
5860            / ----
5861            / 
5862            / : and support for :
5863            / 
5864            / ----
5865            
5866            
5867            / ----	:DONE -- word # 103
5868            
5869            W103Name,
5870            
5871            	/ stringengize( :DONE )
5872 05375 0072 72
5873 05376 0104 104
5874 05377 0117 117
5875 05400 0116 116
5876 05401 0105 105
5877            
5878 05402 0005 	.+0-W103Name
5879 05403 0034 	W103CFA-W102CFA
5880            W103CFA,
5881 05404 3760 	W7CFA-.		/ (VAR)
5882            W103PFA,
5883 05405 0000 	0
5884            
5885            
5886            / ----	:DP -- word # 104
5887            
5888            W104Name,
5889            
5890            	/ stringengize( :DP )
5891 05406 0072 72
5892 05407 0104 104
5893 05410 0120 120
5894            
5895 05411 0003 	.+0-W104Name
5896 05412 0007 	W104CFA-W103CFA
5897            W104CFA,
5898 05413 3751 	W7CFA-.		/ (VAR)
5899            W104PFA,
5900 05414 0000 	0
5901            
5902            
5903            / ----	:LAST -- word # 105
5904            
5905            W105Name,
5906            
5907            	/ stringengize( :LAST )
5908 05415 0072 72
5909 05416 0114 114
5910 05417 0101 101
5911 05420 0123 123
5912 05421 0124 124
5913            
5914 05422 0005 	.+0-W105Name
5915 05423 0011 	W105CFA-W104CFA
5916            W105CFA,
5917 05424 3740 	W7CFA-.		/ (VAR)
5918            W105PFA,
5919 05425 0000 	0
5920            
5921            
5922            / ----	:MP -- word # 106
5923            
5924            W106Name,
5925            
5926            	/ stringengize( :MP )
5927 05426 0072 72
5928 05427 0115 115
5929 05430 0120 120
5930            
5931 05431 0003 	.+0-W106Name
5932 05432 0007 	W106CFA-W105CFA
5933            W106CFA,
5934 05433 3731 	W7CFA-.		/ (VAR)
5935            W106PFA,
5936 05434 0000 	0
5937            / --	; - Terminat a : definition
5938            / 
5939            / ( -> )
5940            / 
5941            / This word compiles (;) into the dictionary then sets :DONE to
5942            / a non-zero value so : knows to exit.
5943            
5944            
5945            / ----	; -- word # 107
5946            
5947            W107Name,
5948            
5949            	/ stringengize( ; )
5950 05435 0073 73
5951            
5952 05436 0201 	.+200-W107Name
5953 05437 0005 	W107CFA-W106CFA
5954            W107CFA,
5955 05440 3621 	W4CFA-.		/ (:)
5956            W107PFA,
5957 05441 7267 	W87CFA-.		/ (OLIT)
5958 05442 3645 	W5CFA-.		/ (;)
5959 05443 7412 	W93CFA-.		/ O,
5960 05444 5115 	W21CFA-.		/ 1
5961 05445 7737 	W103CFA-.		/ :DONE
5962 05446 4143 	W16CFA-.		/ !
5963 05447 3640 	W5CFA-.		/ (;)
5964            / --	:ABORT - Abort a : definition
5965            / 
5966            / ( -> )
5967            / 
5968            / This word is used to abort while compiling a : definition. It
5969            / restores DP and LAST to their original values before ABORTing.
5970            
5971            
5972            / ----	:ABORT -- word # 108
5973            
5974            W108Name,
5975            
5976            	/ stringengize( :ABORT )
5977 05450 0072 72
5978 05451 0101 101
5979 05452 0102 102
5980 05453 0117 117
5981 05454 0122 122
5982 05455 0124 124
5983            
5984 05456 0006 	.+0-W108Name
5985 05457 0020 	W108CFA-W107CFA
5986            W108CFA,
5987 05460 3601 	W4CFA-.		/ (:)
5988            W108PFA,
5989 05461 7732 	W104CFA-.		/ :DP
5990 05462 4045 	W12CFA-.		/ @
5991 05463 7233 	W86CFA-.		/ DP
5992 05464 4125 	W16CFA-.		/ !
5993 05465 7737 	W105CFA-.		/ :LAST
5994 05466 4041 	W12CFA-.		/ @
5995 05467 6077 	W67CFA-.		/ LAST
5996 05470 4121 	W16CFA-.		/ !
5997 05471 7214 	W56CFA-.		/ ABORT
5998 05472 3615 	W5CFA-.		/ (;)
5999            / --	: - Compile a FORTH word into the dictionary
6000            / 
6001            / ( -> )
6002            / 
6003            / This word adds a new executable FORTH word to the dictionary; it is
6004            / remarkably similar to INTERPRET, with a few exceptions:
6005            / 
6006            / 	- Non-immedate words are compiled into the dictionary
6007            / 	  instead of being executed
6008            / 
6009            / 	- Literals are compiled into the dictionary instead
6010            / 	  of being left on the math stack.
6011            
6012            
6013            / ----	: -- word # 109
6014            
6015            W109Name,
6016            
6017            	/ stringengize( : )
6018 05473 0072 72
6019            
6020 05474 0001 	.+0-W109Name
6021 05475 0016 	W109CFA-W108CFA
6022            W109CFA,
6023 05476 3563 	W4CFA-.		/ (:)
6024            W109PFA,
6025            / *** ENTRY ***
6026            / 
6027            / M:
6028            / R: Return address
6029            / State A: Initialize :DP and :LAST so we can undo the changes we make 
6030            / to the dictionary if necessary. Initialize :DONE so we'll keep fetching
6031            / lines until ; is executed. Initialize :MP so we can do a smidgen of
6032            / error checking at ; time. Create the name and compile its CFA to point
6033            / at (:). Go to state B.
6034            / 
6035            / M:
6036            W109a,
6037 05477 5055 	W44CFA-.		/ 0
6038 05500 7704 	W103CFA-.		/ :DONE
6039 05501 4110 	W16CFA-.		/ !
6040 05502 7214 	W86CFA-.		/ DP
6041 05503 4024 	W12CFA-.		/ @
6042 05504 7707 	W104CFA-.		/ :DP
6043 05505 4104 	W16CFA-.		/ !
6044 05506 6060 	W67CFA-.		/ LAST
6045 05507 4020 	W12CFA-.		/ @
6046 05510 7714 	W105CFA-.		/ :LAST
6047 05511 4100 	W16CFA-.		/ !
6048 05512 4450 	W31CFA-.		/ MP@
6049 05513 7720 	W106CFA-.		/ :MP
6050 05514 4075 	W16CFA-.		/ !
6051 05515 7446 	W96CFA-.		/ CREATE
6052 05516 7212 	W87CFA-.		/ (OLIT)
6053 05517 3542 	W4CFA-.		/ (:)
6054 05520 7335 	W93CFA-.		/ O,
6055            / State B: Fetch the next token from the input buffer buffer. If there is
6056            / no next token, go to state H. Otheriwse, go to state C. 
6057            / 
6058            / Note that since we may have executed an immediate word, the math stack
6059            / depth is indeterminate starting here.
6060            / 
6061            / M: ?, Token address, Token length
6062            W109b,
6063 05521 5712 	W65CFA-.		/ TOKEN
6064 05522 4214 	W20CFA-.		/ DUP
6065 05523 3714 	W10CFA-.		/ (0BRANCH)
6066 05524 0045 	W109h-.
6067            / State C: We have a token. Look it up in the dictionary. If it's not
6068            / there, go to state I. Otherwise, go to state D.
6069            / 
6070            / M: ?, Token address, Token count, CFA of word named by Token
6071            W109c,
6072 05525 6172 	W71CFA-.		/ FIND
6073 05526 4210 	W20CFA-.		/ DUP
6074 05527 3710 	W10CFA-.		/ (0BRANCH)
6075 05530 0046 	W109i-.
6076            / State D: We've found the word, so we can toss the token address and
6077            / byte count. Fetch the flag byte and see if it's an immediate word.
6078            / If it's an immediate word, go to state E. Otherwise, go to state L.
6079            / 
6080            / M: ?, CFA
6081            W109d,
6082 05531 4227 	W23CFA-.		/ SWAP
6083 05532 4257 	W24CFA-.		/ DROP
6084 05533 4225 	W23CFA-.		/ SWAP
6085 05534 4255 	W24CFA-.		/ DROP
6086 05535 4201 	W20CFA-.		/ DUP
6087 05536 4772 	W40CFA-.		/ (LIT)
6088 05537 7776 	37777777776		/ -2
6089 05540 4504 	W22CFA-.		/ +
6090 05541 3766 	W12CFA-.		/ @
6091 05542 4766 	W40CFA-.		/ (LIT)
6092 05543 0200 	200		/ 128
6093 05544 4531 	W34CFA-.		/ AND
6094 05545 3672 	W10CFA-.		/ (0BRANCH)
6095 05546 0050 	W109l-.
6096            / State E: We have an immediate word. Execute the word and look to 
6097            / see if we're done compiling. If we are done compiling, go to state F.
6098            / Otherwise, go to state B.
6099            / 
6100            / M: ?
6101            W109e,
6102 05547 3472 	W3CFA-.		/ EXEC
6103 05550 7634 	W103CFA-.		/ :DONE
6104 05551 3756 	W12CFA-.		/ @
6105 05552 3665 	W10CFA-.		/ (0BRANCH)
6106 05553 7746 	W109b-.
6107            / State F: We're done compiling. We need to make certain everything the
6108            / immediate words left on the math stack has been popped off. Fetch the
6109            / math stack pointer and compare it to the math stack pointer we had
6110            / on entry. If they match, we don't have any leftover boogers on the
6111            / math stack; exit. Otherwise, go to state G.
6112            / 
6113            / M:		( if we exit )
6114            / M: ?		( if we go to state G)
6115            W109f,
6116 05554 4406 	W31CFA-.		/ MP@
6117 05555 7656 	W106CFA-.		/ :MP
6118 05556 3751 	W12CFA-.		/ @
6119 05557 4421 	W32CFA-.		/ -
6120 05560 3657 	W10CFA-.		/ (0BRANCH)
6121 05561 0040 	W109z-.
6122            / State G: Argh! We've boogerd up the math stack and not wiped it off.
6123            / Display an error message and :ABORT.
6124            / 
6125            / M: Doesn't matter since we're :ABORTing.
6126            W109g,
6127 05562 7146 	W87CFA-.		/ (OLIT)
6128 05563 7713 	W109CFA-.		/ :
6129 05564 6012 	W68CFA-.		/ ID>$
6130 05565 5116 	W52CFA-.		/ TYPE
6131 05566 0043 	W110CFA-.		/ NEST?
6132 05567 5114 	W52CFA-.		/ TYPE
6133 05570 7670 	W108CFA-.		/ :ABORT
6134            / State H: We've hit the end of the line before encountering ;. Clean the
6135            / token info off the math stack and get another line of input. Go back
6136            / to state B.
6137            / 
6138            / M: ?
6139            W109h,
6140 05571 4220 	W24CFA-.		/ DROP
6141 05572 4217 	W24CFA-.		/ DROP
6142 05573 5356 	W61CFA-.		/ GETLINE
6143 05574 3620 	W8CFA-.		/ (BRANCH)
6144 05575 7724 	W109b-.
6145            / State I: We could not find the token in the dictionary. This may
6146            / be a number. If so, go to state J. Otherwise, go to state K.
6147            / 
6148            / M: ?, Token address, Token count
6149            W109i,
6150 05576 4213 	W24CFA-.		/ DROP
6151 05577 6353 	W76CFA-.		/ ISNUMBER
6152 05600 3637 	W10CFA-.		/ (0BRANCH)
6153 05601 0010 	W109k-.
6154            / State J: We have a literal. Convert it to binary and compile it into the
6155            / dictionary. Go to state B.
6156            W109j,
6157 05602 6277 	W75CFA-.		/ >NYBBLES
6158 05603 7125 	W87CFA-.		/ (OLIT)
6159 05604 4724 	W40CFA-.		/ (LIT)
6160 05605 7250 	W93CFA-.		/ O,
6161 05606 7227 	W92CFA-.		/ ,
6162 05607 3605 	W8CFA-.		/ (BRANCH)
6163 05610 7711 	W109b-.
6164            / State K: Our token is bogus; it isn't a number and it isn't in the 
6165            / dictionary. Display tthe token so the user knows why were :ABORTing
6166            / then :ABORT.
6167            / 
6168            / M: Doesn't matter since we're :ABORTing.
6169            W109k,
6170 05611 5072 	W52CFA-.		/ TYPE
6171 05612 4716 	W40CFA-.		/ (LIT)
6172 05613 0077 	77		/ 63
6173 05614 0363 	W47CFA-.		/ EMIT
6174 05615 7643 	W108CFA-.		/ :ABORT
6175            / State L: We've found the token in the dictionary and it is not an
6176            / immediate word. Compile a reference to the word into the dictionary
6177            / and go to state B.
6178            / 
6179            / M: ?
6180            W109l,
6181 05616 7237 	W93CFA-.		/ O,
6182 05617 3575 	W8CFA-.		/ (BRANCH)
6183 05620 7701 	W109b-.
6184            / *** EXIT ***
6185            / 
6186            / M:
6187            / R:
6188            W109z,
6189 05621 3466 	W5CFA-.		/ (;)
6190            / --	NEST? - This word contains the error message displayed by :
6191            / when it believes the control structure nesting is bad. It may
6192            / also be displayed by other control structure words.
6193            
6194            
6195            / ----	NEST? -- word # 110
6196            
6197            W110Name,
6198            
6199            	/ stringengize( NEST? )
6200 05622 0116 116
6201 05623 0105 105
6202 05624 0123 123
6203 05625 0124 124
6204 05626 0077 77
6205            
6206 05627 0005 	.+0-W110Name
6207 05630 0133 	W110CFA-W109CFA
6208            W110CFA,
6209 05631 3635 	W11CFA-.		/ ($)
6210            W110PFA,
6211            /< Nest?\r\n>
6212 05632 0010 	W110End-W110Begin
6213            	W110Begin,
6214            
6215            	/ stringengize(  Nest?\r\n )
6216 05633 0040 40
6217 05634 0116 116
6218 05635 0145 145
6219 05636 0163 163
6220 05637 0164 164
6221 05640 0077 77
6222 05641 0015 15
6223 05642 0012 12
6224            
6225            W110End,
6226            / --	IMMEDIATE - Flags the last word in the dictionary as immediate.
6227            / 
6228            / ( -> )
6229            / 
6230            / This word sets the IMMEDIATE bit in the flags byte of the
6231            / word pointed to by LAST.
6232            
6233            
6234            / ----	IMMEDIATE -- word # 111
6235            
6236            W111Name,
6237            
6238            	/ stringengize( IMMEDIATE )
6239 05643 0111 111
6240 05644 0115 115
6241 05645 0115 115
6242 05646 0105 105
6243 05647 0104 104
6244 05650 0111 111
6245 05651 0101 101
6246 05652 0124 124
6247 05653 0105 105
6248            
6249 05654 0011 	.+0-W111Name
6250 05655 0025 	W111CFA-W110CFA
6251            W111CFA,
6252 05656 3403 	W4CFA-.		/ (:)
6253            W111PFA,
6254 05657 5707 	W67CFA-.		/ LAST
6255 05660 3647 	W12CFA-.		/ @
6256 05661 4647 	W40CFA-.		/ (LIT)
6257 05662 7776 	37777777776		/ -2
6258 05663 4361 	W22CFA-.		/ +
6259 05664 4052 	W20CFA-.		/ DUP
6260 05665 3642 	W12CFA-.		/ @
6261 05666 4642 	W40CFA-.		/ (LIT)
6262 05667 0200 	200		/ 128
6263 05670 4435 	W35CFA-.		/ OR
6264 05671 4067 	W23CFA-.		/ SWAP
6265 05672 3747 	W17CFA-.		/ B!
6266 05673 3414 	W5CFA-.		/ (;)
6267            / ----
6268            / 
6269            / DO loops
6270            / 
6271            / ----
6272            / --	DO - Compile the top of a do loop
6273            / 
6274            / ( -> Top of loop, 1 )
6275            / 
6276            / This word compiles a (DO) into the dictionary and then leaves a
6277            / booger the math stack containing the address of the byte after
6278            / (DO) to allow LOOP and +LOOP to find the top of the loop.
6279            
6280            
6281            / ----	DO -- word # 112
6282            
6283            W112Name,
6284            
6285            	/ stringengize( DO )
6286 05674 0104 104
6287 05675 0117 117
6288            
6289 05676 0202 	.+200-W112Name
6290 05677 0022 	W112CFA-W111CFA
6291            W112CFA,
6292 05700 3361 	W4CFA-.		/ (:)
6293            W112PFA,
6294 05701 7027 	W87CFA-.		/ (OLIT)
6295 05702 6535 	W49CFA-.		/ (DO)
6296 05703 7152 	W93CFA-.		/ O,
6297 05704 7012 	W86CFA-.		/ DP
6298 05705 3622 	W12CFA-.		/ @
6299 05706 4653 	W21CFA-.		/ 1
6300 05707 3400 	W5CFA-.		/ (;)
6301            / --	LOOP - Compile the bottom of a do loop
6302            / 
6303            / ( Address of top of loop, Booger type -> )
6304            / 
6305            / This word coppiles a (LOOP) into the dictionary followed by the
6306            / offset to the top of the do loop. The top of the do loop is left
6307            / as a booger on the math stack by DO.
6308            / 
6309            / The booger is check to ensure that it's a DO-booger. If the top
6310            / of the math stack is not a DO-booger, "Nest?" is printed and
6311            / compilation is :ABORTed.
6312            
6313            
6314            / ----	LOOP -- word # 113
6315            
6316            W113Name,
6317            
6318            	/ stringengize( LOOP )
6319 05710 0114 114
6320 05711 0117 117
6321 05712 0117 117
6322 05713 0120 120
6323            
6324 05714 0204 	.+200-W113Name
6325 05715 0016 	W113CFA-W112CFA
6326            W113CFA,
6327 05716 3343 	W4CFA-.		/ (:)
6328            W113PFA,
6329 05717 7011 	W87CFA-.		/ (OLIT)
6330 05720 6374 	W50CFA-.		/ (LOOP)
6331 05721 7134 	W93CFA-.		/ O,
6332 05722 4637 	W21CFA-.		/ 1
6333 05723 4255 	W32CFA-.		/ -
6334 05724 3513 	W10CFA-.		/ (0BRANCH)
6335 05725 0012 	W1130-.
6336 05726 7002 	W87CFA-.		/ (OLIT)
6337 05727 7767 	W113CFA-.		/ LOOP
6338 05730 5646 	W68CFA-.		/ ID>$
6339 05731 4752 	W52CFA-.		/ TYPE
6340 05732 7677 	W110CFA-.		/ NEST?
6341 05733 4750 	W52CFA-.		/ TYPE
6342 05734 7524 	W108CFA-.		/ :ABORT
6343 05735 3457 	W8CFA-.		/ (BRANCH)
6344 05736 0002 	W1131-.
6345            W1130,
6346 05737 7116 	W93CFA-.		/ O,
6347            W1131,
6348 05740 3347 	W5CFA-.		/ (;)
6349            / --	+LOOP - Compile the bottom of a do loop
6350            / 
6351            / ( Address of top of loop, Booger type -> )
6352            / 
6353            / This word coppiles a (+LOOP) into the dictionary followed by the
6354            / offset to the top of the do loop. The top of the do loop is left
6355            / as a booger on the math stack by DO.
6356            / 
6357            / The booger is check to ensure that it's a DO-booger. If the top
6358            / of the math stack is not a DO-booger, "Nest?" is printed and
6359            / compilation is :ABORTed.
6360            
6361            
6362            / ----	+LOOP -- word # 114
6363            
6364            W114Name,
6365            
6366            	/ stringengize( +LOOP )
6367 05741 0053 53
6368 05742 0114 114
6369 05743 0117 117
6370 05744 0117 117
6371 05745 0120 120
6372            
6373 05746 0205 	.+200-W114Name
6374 05747 0032 	W114CFA-W113CFA
6375            W114CFA,
6376 05750 3311 	W4CFA-.		/ (:)
6377            W114PFA,
6378 05751 6757 	W87CFA-.		/ (OLIT)
6379 05752 6412 	W79CFA-.		/ (+LOOP)
6380 05753 7102 	W93CFA-.		/ O,
6381 05754 4605 	W21CFA-.		/ 1
6382 05755 4223 	W32CFA-.		/ -
6383 05756 3461 	W10CFA-.		/ (0BRANCH)
6384 05757 0012 	W1140-.
6385 05760 6750 	W87CFA-.		/ (OLIT)
6386 05761 7767 	W114CFA-.		/ +LOOP
6387 05762 5614 	W68CFA-.		/ ID>$
6388 05763 4720 	W52CFA-.		/ TYPE
6389 05764 7645 	W110CFA-.		/ NEST?
6390 05765 4716 	W52CFA-.		/ TYPE
6391 05766 7472 	W108CFA-.		/ :ABORT
6392 05767 3425 	W8CFA-.		/ (BRANCH)
6393 05770 0002 	W1141-.
6394            W1140,
6395 05771 7064 	W93CFA-.		/ O,
6396            W1141,
6397 05772 3315 	W5CFA-.		/ (;)
6398            / ----
6399            / 
6400            /     REPEAT loops
6401            / 
6402            / ----
6403            / --	REPEAT - Compile the top of a REPEAT/UNTIL loop.
6404            / 
6405            / ( -> Address of the top of the loop, 2 )
6406            / 
6407            / This word puts a REPEAT-booger on the math stack for later
6408            / reference by UNTIL. The REPEAT-booger contains the 
6409            / dictionary pointer when REPEAT was executed; i.e., it contains
6410            / the address of the top of the loop.
6411            
6412            
6413            / ----	REPEAT -- word # 115
6414            
6415            W115Name,
6416            
6417            	/ stringengize( REPEAT )
6418 05773 0122 122
6419 05774 0105 105
6420 05775 0120 120
6421 05776 0105 105
6422 05777 0101 101
6423 06000 0124 124
6424            
6425 06001 0206 	.+200-W115Name
6426 06002 0033 	W115CFA-W114CFA
6427            W115CFA,
6428 06003 3256 	W4CFA-.		/ (:)
6429            W115PFA,
6430 06004 6712 	W86CFA-.		/ DP
6431 06005 3522 	W12CFA-.		/ @
6432 06006 4522 	W40CFA-.		/ (LIT)
6433 06007 0002 	2		/ 2
6434 06010 3277 	W5CFA-.		/ (;)
6435            / --	UNTIL - Compile to bottom of a REPEAT/UNTIL loop.
6436            / 
6437            / ( Address of top loop, type of booger -> )
6438            / 
6439            / This word compiles a (0BRANCH) at the end of the loop which
6440            / will branch back to the top of the loop. Thus, the loop is
6441            / repeated until the top of the math stack at the bottom of
6442            / the loop is non-zero.
6443            
6444            
6445            / ----	UNTIL -- word # 116
6446            
6447            W116Name,
6448            
6449            	/ stringengize( UNTIL )
6450 06011 0125 125
6451 06012 0116 116
6452 06013 0124 124
6453 06014 0111 111
6454 06015 0114 114
6455            
6456 06016 0205 	.+200-W116Name
6457 06017 0015 	W116CFA-W115CFA
6458            W116CFA,
6459 06020 3241 	W4CFA-.		/ (:)
6460            W116PFA,
6461 06021 6707 	W87CFA-.		/ (OLIT)
6462 06022 3415 	W10CFA-.		/ (0BRANCH)
6463 06023 7032 	W93CFA-.		/ O,
6464 06024 4504 	W40CFA-.		/ (LIT)
6465 06025 0002 	2		/ 2
6466 06026 4152 	W32CFA-.		/ -
6467 06027 3410 	W10CFA-.		/ (0BRANCH)
6468 06030 0012 	W1160-.
6469 06031 6677 	W87CFA-.		/ (OLIT)
6470 06032 7766 	W116CFA-.		/ UNTIL
6471 06033 5543 	W68CFA-.		/ ID>$
6472 06034 4647 	W52CFA-.		/ TYPE
6473 06035 7574 	W110CFA-.		/ NEST?
6474 06036 4645 	W52CFA-.		/ TYPE
6475 06037 7421 	W108CFA-.		/ :ABORT
6476 06040 3354 	W8CFA-.		/ (BRANCH)
6477 06041 0002 	W1161-.
6478            W1160,
6479 06042 7013 	W93CFA-.		/ O,
6480            W1161,
6481 06043 3244 	W5CFA-.		/ (;)
6482            / ----
6483            / 
6484            / IF
6485            / 
6486            / ----
6487            / --	IF - Compile a conditional branch
6488            / 
6489            / ( -> Address of offset in conditional branch, 3 )
6490            / 
6491            /  This word compiles a (0BRANCH) into the code, leaving space
6492            / for the offset of the branch following it. The offset will be
6493            / filled in later by either ELSE or ENDIF. Since ELSE or ENDIF
6494            / need to know where the offset should be stored, the address of
6495            / the offset is left on the math stack as an IF-booger.
6496            
6497            
6498            / ----	IF -- word # 117
6499            
6500            W117Name,
6501            
6502            	/ stringengize( IF )
6503 06044 0111 111
6504 06045 0106 106
6505            
6506 06046 0202 	.+200-W117Name
6507 06047 0030 	W117CFA-W116CFA
6508            W117CFA,
6509 06050 3211 	W4CFA-.		/ (:)
6510            W117PFA,
6511 06051 6657 	W87CFA-.		/ (OLIT)
6512 06052 3365 	W10CFA-.		/ (0BRANCH)
6513 06053 7002 	W93CFA-.		/ O,
6514 06054 6642 	W86CFA-.		/ DP
6515 06055 3452 	W12CFA-.		/ @
6516 06056 3660 	W20CFA-.		/ DUP
6517 06057 6776 	W93CFA-.		/ O,
6518 06060 4450 	W40CFA-.		/ (LIT)
6519 06061 0003 	3		/ 3
6520 06062 3225 	W5CFA-.		/ (;)
6521            / --	ELSE - Compile the false branch of an IF
6522            / 
6523            / ( Address of IF branch, type of booger -> Address of ELSE branch, 3 )
6524            / 
6525            / This word terminates the true branch of an IF and starts the false
6526            / branch.
6527            / 
6528            / An unconditional branch is compiled following the true section.
6529            / This will be filled in later by ENDIF. The booger left behind by IF
6530            / is then filled in to point to the start of the false code. The
6531            / IF-booger left by IF is replaced by an IF-booger for the branch
6532            / at the end of the true section.
6533            
6534            
6535            / ----	ELSE -- word # 118
6536            
6537            W118Name,
6538            
6539            	/ stringengize( ELSE )
6540 06063 0105 105
6541 06064 0114 114
6542 06065 0123 123
6543 06066 0105 105
6544            
6545 06067 0204 	.+200-W118Name
6546 06070 0021 	W118CFA-W117CFA
6547            W118CFA,
6548 06071 3170 	W4CFA-.		/ (:)
6549            W118PFA,
6550 06072 6636 	W87CFA-.		/ (OLIT)
6551 06073 3321 	W8CFA-.		/ (BRANCH)
6552 06074 6761 	W93CFA-.		/ O,
6553            / Now we need to be a bit careful. We have to stash away the address
6554            / of teh offset portion of the branch we just compiled before we
6555            / can fill in the IF-booger left behind by IF (we want the original
6556            / IF-boogerto branch _after_ the relative offset, not to it).
6557            / 
6558            / However, we also don't want to put dependencies in this code
6559            / about the size of a relative offset. So what we're going to do
6560            / is fetch DP and stash it on the return stack while we fill in the
6561            / original IF-booger. Then we can use the return stack to generate
6562            / the new IF-booger.
6563 06075 6621 	W86CFA-.		/ DP
6564 06076 3431 	W12CFA-.		/ @
6565 06077 3637 	W20CFA-.		/ DUP
6566 06100 3726 	W25CFA-.		/ >R
6567 06101 6754 	W93CFA-.		/ O,
6568 06102 0014 	W119CFA-.		/ ENDIF
6569 06103 3752 	W26CFA-.		/ <R
6570 06104 4424 	W40CFA-.		/ (LIT)
6571 06105 0003 	3		/ 3
6572 06106 3201 	W5CFA-.		/ (;)
6573            / --	ENDIF - Complete the compilation of an IF construct
6574            / 
6575            / ( Address of branch offset to be filled in, type of booger -> )
6576            / 
6577            / This word fills in the open branch offset left behind by an
6578            / IF or an ELSE. The offset from the original branch is written to
6579            / point to the current DP, which is just past the end of the IF.
6580            
6581            
6582            / ----	ENDIF -- word # 119
6583            
6584            W119Name,
6585            
6586            	/ stringengize( ENDIF )
6587 06107 0105 105
6588 06110 0116 116
6589 06111 0104 104
6590 06112 0111 111
6591 06113 0106 106
6592            
6593 06114 0205 	.+200-W119Name
6594 06115 0025 	W119CFA-W118CFA
6595            W119CFA,
6596 06116 3143 	W4CFA-.		/ (:)
6597            W119PFA,
6598 06117 4411 	W40CFA-.		/ (LIT)
6599 06120 0003 	3		/ 3
6600 06121 4057 	W32CFA-.		/ -
6601 06122 3315 	W10CFA-.		/ (0BRANCH)
6602 06123 0012 	W1190-.
6603 06124 6604 	W87CFA-.		/ (OLIT)
6604 06125 7723 	W117CFA-.		/ IF
6605 06126 5450 	W68CFA-.		/ ID>$
6606 06127 4554 	W52CFA-.		/ TYPE
6607 06130 7501 	W110CFA-.		/ NEST?
6608 06131 4552 	W52CFA-.		/ TYPE
6609 06132 7326 	W108CFA-.		/ :ABORT
6610 06133 3261 	W8CFA-.		/ (BRANCH)
6611 06134 0005 	W1191-.
6612            W1190,
6613 06135 6561 	W86CFA-.		/ DP
6614 06136 3371 	W12CFA-.		/ @
6615 06137 3621 	W23CFA-.		/ SWAP
6616 06140 6630 	W89CFA-.		/ O!
6617            W1191,
6618 06141 3146 	W5CFA-.		/ (;)
6619            / 	?EMIT             M: ( -> Flag )
6620            / 	                  R: ( -> )
6621            / 
6622            / 	If the console is ready to accept a character, a non-zero flag
6623            / 	is pushed onto the math stack. Otherwise, a zero flag is pushed.
6624            / 	The work is actually done by machine code at label MSQE.
6625            
6626            
6627            / ----	?EMIT -- word # 120
6628            
6629            W120Name,
6630            
6631            	/ stringengize( ?EMIT )
6632 06142 0077 77
6633 06143 0105 105
6634 06144 0115 115
6635 06145 0111 111
6636 06146 0124 124
6637            
6638 06147 0005 	.+0-W120Name
6639 06150 0033 	W120CFA-W119CFA
6640            W120CFA,
6641 06151 0000 	W120CFA-.		/ ?EMIT
6642            W120PFA,
6643 06152 4460 	JMS I StupidLiteral0		/ MSQE
6644 06153 0666 	MSQE
6645 06154 4503 	JMS I StupidStorePC0		/ PC!
6646            / 	(EMIT)              M: ( Character -> )
6647            / 	                    R: ( -> )
6648            / 
6649            / 	Displays the character from the top of the math stack on the
6650            / 	console. The character is dropped. The console is assumed to
6651            / 	be ready to print. Handled by machine code at label MSE.
6652            
6653            
6654            / ----	(EMIT) -- word # 121
6655            
6656            W121Name,
6657            
6658            	/ stringengize( (EMIT) )
6659 06155 0050 50
6660 06156 0105 105
6661 06157 0115 115
6662 06160 0111 111
6663 06161 0124 124
6664 06162 0051 51
6665            
6666 06163 0006 	.+0-W121Name
6667 06164 0014 	W121CFA-W120CFA
6668            W121CFA,
6669 06165 0000 	W121CFA-.		/ (EMIT)
6670            W121PFA,
6671 06166 4460 	JMS I StupidLiteral0		/ MSE
6672 06167 0674 	MSE
6673 06170 4503 	JMS I StupidStorePC0		/ PC!
6674            / 	EMIT                M: ( Character -> )
6675            / 	                    R: ( -> )
6676            / 
6677            / 	Waits for the console to become ready then displays the character
6678            / at the top of the math stack.
6679            
6680            
6681            / ----	EMIT -- word # 47
6682            
6683            W47Name,
6684            
6685            	/ stringengize( EMIT )
6686 06171 0105 105
6687 06172 0115 115
6688 06173 0111 111
6689 06174 0124 124
6690            
6691 06175 0004 	.+0-W47Name
6692 06176 0012 	W47CFA-W121CFA
6693            W47CFA,
6694 06177 3062 	W4CFA-.		/ (:)
6695            W47PFA,
6696            W470,
6697 06200 7751 	W120CFA-.		/ ?EMIT
6698 06201 3236 	W10CFA-.		/ (0BRANCH)
6699 06202 7776 	W470-.
6700 06203 7762 	W121CFA-.		/ (EMIT)
6701 06204 3103 	W5CFA-.		/ (;)
6702            / 	?KEY              M: ( -> Flag )
6703            / 	                  R: ( -> )
6704            / 
6705            / 	If the console has received a character, a non-zero flag is
6706            / 	pushed onto the math sack. Otherwise, a zero flag is pushed.
6707            / 	The work is actually done by machine code at label MSQK.
6708            
6709            
6710            / ----	?KEY -- word # 55
6711            
6712            W55Name,
6713            
6714            	/ stringengize( ?KEY )
6715 06205 0077 77
6716 06206 0113 113
6717 06207 0105 105
6718 06210 0131 131
6719            
6720 06211 0004 	.+0-W55Name
6721 06212 0014 	W55CFA-W47CFA
6722            W55CFA,
6723 06213 0000 	W55CFA-.		/ ?KEY
6724            W55PFA,
6725 06214 4460 	JMS I StupidLiteral0		/ MSQK
6726 06215 0705 	MSQK
6727 06216 4503 	JMS I StupidStorePC0		/ PC!
6728            / (KEY)               M: ( -> Character )
6729            / 
6730            / 	Reads a character from the console and pushes it onto the
6731            / 	math stack. It is assumed the console is ready to supply a
6732            / 	character. Handled by machine code at label MSK.
6733            
6734            
6735            / ----	(KEY) -- word # 122
6736            
6737            W122Name,
6738            
6739            	/ stringengize( (KEY) )
6740 06217 0050 50
6741 06220 0113 113
6742 06221 0105 105
6743 06222 0131 131
6744 06223 0051 51
6745            
6746 06224 0005 	.+0-W122Name
6747 06225 0013 	W122CFA-W55CFA
6748            W122CFA,
6749 06226 0000 	W122CFA-.		/ (KEY)
6750            W122PFA,
6751 06227 4460 	JMS I StupidLiteral0		/ MSK
6752 06230 0713 	MSK
6753 06231 4503 	JMS I StupidStorePC0		/ PC!
6754            / 	KEY                 M: ( -> Character )
6755            / 	                    R: ( -> )
6756            / 
6757            / 	Waits for a character to become available at the console and
6758            / 	then fetches it.
6759            
6760            
6761            / ----	KEY -- word # 62
6762            
6763            W62Name,
6764            
6765            	/ stringengize( KEY )
6766 06232 0113 113
6767 06233 0105 105
6768 06234 0131 131
6769            
6770 06235 0003 	.+0-W62Name
6771 06236 0011 	W62CFA-W122CFA
6772            W62CFA,
6773 06237 3022 	W4CFA-.		/ (:)
6774            W62PFA,
6775            W620,
6776 06240 7753 	W55CFA-.		/ ?KEY
6777 06241 3176 	W10CFA-.		/ (0BRANCH)
6778 06242 7776 	W620-.
6779 06243 7763 	W122CFA-.		/ (KEY)
6780 06244 4264 	W40CFA-.		/ (LIT)
6781 06245 0177 	177		/ 0X7F
6782 06246 4027 	W34CFA-.		/ AND
6783 06247 3040 	W5CFA-.		/ (;)
6784            / 	BYE			Special!
6785            / 
6786            / 	Exits to the operating system.
6787            
6788            
6789            / ----	BYE -- word # 123
6790            
6791            W123Name,
6792            
6793            	/ stringengize( BYE )
6794 06250 0102 102
6795 06251 0131 131
6796 06252 0105 105
6797            
6798 06253 0003 	.+0-W123Name
6799 06254 0016 	W123CFA-W62CFA
6800            W123CFA,
6801 06255 0000 	W123CFA-.		/ BYE
6802            W123PFA,
6803 06256 4460 	JMS I StupidLiteral0		/ MSBYE
6804 06257 0717 	MSBYE
6805 06260 4503 	JMS I StupidStorePC0		/ PC!
6806            / 	(LASTWORD)              M: ( -> )
6807            / 	                        R: ( -> )
6808            / 
6809            / 	Doesn't do anything, but lets us find the last word in the
6810            / 	dictionary so we can initialize InitialLAST.
6811            
6812            
6813            / ----	(LASTWORD) -- word # 1001
6814            
6815            W1001Name,
6816            
6817            	/ stringengize( (LASTWORD) )
6818 06261 0050 50
6819 06262 0114 114
6820 06263 0101 101
6821 06264 0123 123
6822 06265 0124 124
6823 06266 0127 127
6824 06267 0117 117
6825 06270 0122 122
6826 06271 0104 104
6827 06272 0051 51
6828            
6829 06273 0012 	.+0-W1001Name
6830 06274 0020 	W1001CFA-W123CFA
6831            W1001CFA,
6832 06275 2764 	W4CFA-.		/ (:)
6833            W1001PFA,
6834 06276 3011 	W5CFA-.		/ (;)
6835            
6836            
6837            RamEnd,
6838            
6839            
6840            
6841            / --------- DUMP OF QDL SYMBOL TABLE ----------
6842            /
6843            /
6844            / (COLD) -> W1000
6845            / (LASTWORD) -> W1001
6846            / (NEXT) -> W0
6847            / Next -> W1
6848            / Next_A -> W2
6849            / EXEC -> W3
6850            / (:) -> W4
6851            / (;) -> W5
6852            / (CONSTANT) -> W6
6853            / (VAR) -> W7
6854            / (BRANCH) -> W8
6855            / pBranch -> W9
6856            / (0BRANCH) -> W10
6857            / ($) -> W11
6858            / @ -> W12
6859            / B@ -> W13
6860            / W@ -> W14
6861            / CVTW@ -> W15
6862            / ! -> W16
6863            / B! -> W17
6864            / W! -> W18
6865            / ++ -> W19
6866            / DUP -> W20
6867            / 1 -> W21
6868            / + -> W22
6869            / SWAP -> W23
6870            / DROP -> W24
6871            / >R -> W25
6872            / <R -> W26
6873            / R -> W27
6874            / RP! -> W28
6875            / OVER -> W29
6876            / MP! -> W30
6877            / MP@ -> W31
6878            / - -> W32
6879            / NEG -> W33
6880            / AND -> W34
6881            / OR -> W35
6882            / NOT -> W36
6883            / << -> W37
6884            / >> -> W38
6885            / 0< -> W39
6886            / (LIT) -> W40
6887            / < -> W41
6888            / > -> W42
6889            / 0= -> W43
6890            / 0 -> W44
6891            / = -> W45
6892            / .NYBBLE -> W46
6893            / EMIT -> W47
6894            / .NYBBLES -> W48
6895            / (DO) -> W49
6896            / (LOOP) -> W50
6897            / . -> W51
6898            / TYPE -> W52
6899            / COUNT -> W53
6900            / ?ABORT -> W54
6901            / ?KEY -> W55
6902            / ABORT -> W56
6903            / CR -> W57
6904            / NL -> W58
6905            / INBUF -> W59
6906            / IN -> W60
6907            / GETLINE -> W61
6908            / KEY -> W62
6909            / ISCONTROL -> W63
6910            / NEXTCHAR -> W64
6911            / TOKEN -> W65
6912            / $= -> W66
6913            / LAST -> W67
6914            / ID>$ -> W68
6915            / PREV -> W69
6916            / VLIST -> W70
6917            / FIND -> W71
6918            / DIGITMAP -> W72
6919            / ISDIGIT -> W73
6920            / >NYBBLE -> W74
6921            / >NYBBLES -> W75
6922            / ISNUMBER -> W76
6923            / PROMPT -> W77
6924            / INTERPRET -> W78
6925            / (+LOOP) -> W79
6926            / (DP@) -> W80
6927            / (LAST@) -> W81
6928            / IDMSG1 -> W82
6929            / IDMSG2 -> W83
6930            / IDMSG3 -> W84
6931            / IDENTIFY -> W85
6932            / DP -> W86
6933            / (OLIT) -> W87
6934            / O@ -> W88
6935            / O! -> W89
6936            / B, -> W90
6937            / W, -> W91
6938            / , -> W92
6939            / O, -> W93
6940            / $, -> W94
6941            / ALLOT -> W95
6942            / CREATE -> W96
6943            / NAME? -> W97
6944            / LEN? -> W98
6945            / VARIABLE -> W99
6946            / CONSTANT -> W100
6947            / CODE -> W101
6948            / $ -> W102
6949            / :DONE -> W103
6950            / :DP -> W104
6951            / :LAST -> W105
6952            / :MP -> W106
6953            / ; -> W107
6954            / :ABORT -> W108
6955            / : -> W109
6956            / NEST? -> W110
6957            / IMMEDIATE -> W111
6958            / DO -> W112
6959            / LOOP -> W113
6960            / +LOOP -> W114
6961            / REPEAT -> W115
6962            / UNTIL -> W116
6963            / IF -> W117
6964            / ELSE -> W118
6965            / ENDIF -> W119
6966            / ?EMIT -> W120
6967            / (EMIT) -> W121
6968            / (KEY) -> W122
6969            / BYE -> W123
6970            	$
